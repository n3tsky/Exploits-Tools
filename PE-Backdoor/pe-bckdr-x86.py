#!/usr/bin/python
# Credits:
# http://git.n0p.cc/?p=SectionDoubleP.git;a=blob;f=SectionDoubleP.py
# https://msdn.microsoft.com/en-us/library/ms809762.aspx
#
# TODO
#   - Add new section to put shellcode into
#   - Find code cave to put shellcode into
#   - XOR .text and/or .Xdata sections

import sys
try:
    import pefile
    import argparse
except:
    print "Please install the following modules to ensure %s works" % (sys.argv[0])
    print " - pefile"
    print " - argparse"
    sys.exit(1)

# Load PE file
def load_pe_file(filename):
    print "\n[*] Loading PE file => \"%s\"" % (filename)
    return pefile.PE(filename)

# Go through all PE sections (and display them)
def iterate_trough_pe_sections(pe_struct):
    print "\n - PE sections - %d section(s)" % (pe_struct.FILE_HEADER.NumberOfSections)
    print "\t\tVOffset\tVSize\tSize\t\tName"
    print "\t\t-----------------------------------------------------"
    for section in pe_struct.sections:
        print "\t\t%s\t%s\t%s\t\t%s" % (hex(section.VirtualAddress), hex(section.Misc_VirtualSize), hex(section.SizeOfRawData), section.Name)

def dump_data(pe, address, size):
    blob =  pe.get_data(address, size)
    print format(" ".join("{:02x}".format(ord(c)) for c in blob))

# Perform a quick analysis of PE file
def pe_analysis(pe_struct):
    print "\n[*] Analysis"
    print " - Entry point: 0x%x" % (pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint)
    iterate_trough_pe_sections(pe_struct)
    dump_data(pe_struct, pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, 10)

def adjust_optional_header(pe_struct):
    pe_struct.OPTIONAL_HEADER.SizeOfImage = pe_struct.sections[-1].VirtualAddress + pe_struct.sections[-1].Misc_VirtualSize
    pe_struct.OPTIONAL_HEADER.SizeOfCode = 0
    pe_struct.OPTIONAL_HEADER.SizeOfInitializedData = 0
    pe_struct.OPTIONAL_HEADER.SizeOfUninitializedData = 0

    for section in pe_struct.sections:
        if section.Characteristics & 0x00000020:
            pe_struct.OPTIONAL_HEADER.SizeOfCode += section.SizeOfRawData
        if section.Characteristics & 0x00000040:
            pe_struct.OPTIONAL_HEADER.SizeOfInitializedData += section.SizeOfRawData
        if section.Characteristics & 0x00000080:
            pe_struct.OPTIONAL_HEADER.SizeOfUninitializedData += section.SizeOfRawData

    return pe_struct

def create_new_section(pe_struct, sectionName = ".NewSec", virtualSize = 0x1000, pattern = "\x00", flags = 0xE00000E0):
    print "\n[*] Creating new section"

    # File alignment
    alignment = pe_struct.OPTIONAL_HEADER.FileAlignment
    # Section alignment
    SectionAlignment = pe_struct.OPTIONAL_HEADER.SectionAlignment
    # Get latest section
    latest_section = pe_struct.sections[-1]

    data = virtualSize * "\x00"
    offset_for_new_section = hex(latest_section.VirtualAddress + latest_section.SizeOfRawData)

    print " - Append %d bytes to PE file" % (virtualSize)

    # Append data to file
    full_length = latest_section.PointerToRawData + latest_section.SizeOfRawData
    pe_struct.__data__ = pe_struct.__data__[:full_length] + data

    # Find correct offset (with section alignment)
    virtualAddress = (pe_struct.sections[-1].VirtualAddress + pe_struct.sections[-1].Misc_VirtualSize - (pe_struct.sections[-1].Misc_VirtualSize % SectionAlignment) + SectionAlignment)

    # Add data (of the section header) to the file
    # 0x28 size of section header
    section_table_offset = pe_struct.DOS_HEADER.e_lfanew + 4 + pe_struct.FILE_HEADER.sizeof() + pe_struct.FILE_HEADER.SizeOfOptionalHeader
    section_offset = section_table_offset + pe_struct.FILE_HEADER.NumberOfSections * 0x28

    # Add data of the new section header to PE file
    pe_struct.set_bytes_at_offset(section_offset, sectionName)              # Name of new section
    pe_struct.set_dword_at_offset(section_offset + 0x08, virtualSize)       # virtualSize
    pe_struct.set_dword_at_offset(section_offset + 0x0C, virtualAddress)    # virtualAddress
    pe_struct.set_dword_at_offset(section_offset + 0x10, virtualSize)       # RawSize
    pe_struct.set_dword_at_offset(section_offset + 0x14, full_length)       # RawAddress
    pe_struct.set_dword_at_offset(section_offset + 0x18, 0x00000000)        # RelocAddress
    pe_struct.set_dword_at_offset(section_offset + 0x1C, 0x00000000)        # LineNumbers
    pe_struct.set_word_at_offset(section_offset + 0x20, 0x0000)             # RelocationsNumber
    pe_struct.set_word_at_offset(section_offset + 0x22, 0x0000)             # LinenumbersNumber
    pe_struct.set_dword_at_offset(section_offset + 0x24, flags)             # Flags

    # Add (+1) new section
    pe_struct.FILE_HEADER.NumberOfSections +=1

    pe_struct.parse_sections(section_table_offset) # Fetch the PE file sections
    pe_struct = adjust_optional_header(pe_struct)

    return pe_struct

# Write new PE file
def write_PE_file(pe_struct):
    new_PE_name = FILE.replace(".exe","")
    new_PE_name += "_custom.exe"
    print "\n[*] Writing new PE file => \"%s\"" % (new_PE_name)
    pe_struct.write(filename=new_PE_name)


def parser():
    parser = argparse.ArgumentParser(description="Add a shellcode to an existing PE (x86) or hide the content of a PE")
    parser.add_argument('--file', '-f', required=True, help="PE file to work with")
    parser.add_argument('--output', '-o', required=False, help="Output (PE) file")
    return parser.parse_args()

if __name__ == "__main__":
    args = parser()
    pe_struct = load_pe_file(args.file)
    pe_analysis(pe_struct)
    #new_pe_file = create_new_section(pe_struct)
    #iterate_trough_pe_sections(new_pe_file)
    #write_PE_file(new_pe_file)
