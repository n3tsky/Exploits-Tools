# PE related functions
import os
import random
import string
import pefile
from pwn import disasm, asm

#####################################################
# Utils
#####################################################

# Load PE file
def load_pe_file(filename):
    if os.path.isfile(filename):
        print "\n[*] Loading PE file => \"%s\"" % (filename)
        try:
            return pefile.PE(filename)
        except pefile.PEFormatError:
            print "[!] File (%s) doesn't seem to be a PE file" % (filename)
            sys.exit(1)
    else:
        print "\n[!] File (%s) doesn't exist" % (filename)
        sys.exit(1)

# Write new PE file
def write_PE_file(pe_struct, out_filename):
    if (out_filename == None) or len(out_filename) == 0:
        out_filename = "%s.exe" % ("".join(random.choice(string.ascii_letters) for x in range(10)))
    print "\n[*] Writing new PE file => \"%s\"" % (out_filename)
    pe_struct.write(filename=out_filename)

# Dump opcodes from PE, and display ASM
def dump_data(pe_struct, address, size):
    blob =  pe_struct.get_data(address, size)
    for l in disasm(blob, arch="i386").split("\n"):
        print "\t%s" % (l)

# Find a specific section (with name), and give it back (with index)
def find_section(pe_struct, section_name):
    index = 0
    for section in pe_struct.sections:
        if section_name in section.Name:
            return section, index
        index+=1
    return None,-1

# Create a section name (max size: 5)
def gen_section_name(new_sec_name):
    new_section_name = ".%s" % ("".join(random.choice(string.ascii_letters) for x in range(5)))
    if new_sec_name is not None:
        if len(args.new_sec_name) > 0 and len(args.new_sec_name) <= 5:
            if (args.new_sec_name[0] != "."):
                new_section_name = ".%s" % (args.new_sec_name)
            else:
                new_section_name = "%s" % (args.new_sec_name)
    return new_section_name

#####################################################
# Analysis
#####################################################

# Perform a quick analysis of PE file
def pe_quick_analysis(pe_struct):
    print "\n[*] Analysis"
    # Entry Point
    print " - Entry point: 0x%x" % (pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint)

    # ASLR
    if (pe_struct.OPTIONAL_HEADER.DllCharacteristics & 0x0040):
        print " - ASLR is enabled"
    else:
        print " - ASLR is disabled"

    # PE TYPE
    if (pe_struct.PE_TYPE == 0x10b):
        print " - PE 32-bit!"
    elif (pe_struct.PE_TYPE == 0x20b):
        print " - PE 64-bit!"
    else:
        print " - Unknown type!"
    print ""

# Perform a deeper analysis of PE file
def pe_deeper_analysis(pe_struct):
    # Sections
    iterate_trough_pe_sections(pe_struct)
    # Requires pwntools
    print "\n - ASM instructions @entry point"
    dump_data(pe_struct, pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, 30)

#####################################################
# Sections
#####################################################

# Go through all PE sections (and display them)
def iterate_trough_pe_sections(pe_struct):
    print " - PE sections - %d section(s)" % (pe_struct.FILE_HEADER.NumberOfSections)
    print "\t\tVOffset\t\tVSize\t\tSize\t\tName"
    print "\t\t-----------------------------------------------------"
    for section in pe_struct.sections:
        print "\t\t%-10s\t%-10s\t%-10s\t%-10s" % (hex(section.VirtualAddress), hex(section.Misc_VirtualSize), hex(section.SizeOfRawData), section.Name.replace('\x00',''))

def adjust_optional_header(pe_struct):
    pe_struct.OPTIONAL_HEADER.SizeOfImage = pe_struct.sections[-1].VirtualAddress + pe_struct.sections[-1].Misc_VirtualSize
    pe_struct.OPTIONAL_HEADER.SizeOfCode = 0
    pe_struct.OPTIONAL_HEADER.SizeOfInitializedData = 0
    pe_struct.OPTIONAL_HEADER.SizeOfUninitializedData = 0

    for section in pe_struct.sections:
        if section.Characteristics & 0x00000020:
            pe_struct.OPTIONAL_HEADER.SizeOfCode += section.SizeOfRawData
        if section.Characteristics & 0x00000040:
            pe_struct.OPTIONAL_HEADER.SizeOfInitializedData += section.SizeOfRawData
        if section.Characteristics & 0x00000080:
            pe_struct.OPTIONAL_HEADER.SizeOfUninitializedData += section.SizeOfRawData

    return pe_struct

def create_new_section(pe_struct, sectionName = ".NewSec", virtualSize = 0x1000, pattern = "\x00", flags = 0xE00000E0):
    print "\n[*] Creating new section (\"%s\")" % (sectionName)

    # File alignment
    alignment = pe_struct.OPTIONAL_HEADER.FileAlignment
    # Section alignment
    SectionAlignment = pe_struct.OPTIONAL_HEADER.SectionAlignment
    # Get latest section
    latest_section = pe_struct.sections[-1]

    data = virtualSize * pattern
    offset_for_new_section = hex(latest_section.VirtualAddress + latest_section.SizeOfRawData)

    print " - Append %d bytes to PE file" % (virtualSize)

    # Append data to file
    full_length = latest_section.PointerToRawData + latest_section.SizeOfRawData
    pe_struct.__data__ = pe_struct.__data__[:full_length] + data

    # Find correct offset (with section alignment)
    virtualAddress = (pe_struct.sections[-1].VirtualAddress + pe_struct.sections[-1].Misc_VirtualSize - (pe_struct.sections[-1].Misc_VirtualSize % SectionAlignment) + SectionAlignment)

    # Add data (of the section header) to the file
    # 0x28 size of section header
    section_table_offset = pe_struct.DOS_HEADER.e_lfanew + 4 + pe_struct.FILE_HEADER.sizeof() + pe_struct.FILE_HEADER.SizeOfOptionalHeader
    section_offset = section_table_offset + pe_struct.FILE_HEADER.NumberOfSections * 0x28

    # Add data of the new section header to PE file
    pe_struct.set_bytes_at_offset(section_offset, sectionName)              # Name of new section
    pe_struct.set_dword_at_offset(section_offset + 0x08, virtualSize)       # virtualSize
    pe_struct.set_dword_at_offset(section_offset + 0x0C, virtualAddress)    # virtualAddress
    pe_struct.set_dword_at_offset(section_offset + 0x10, virtualSize)       # RawSize
    pe_struct.set_dword_at_offset(section_offset + 0x14, full_length)       # RawAddress
    pe_struct.set_dword_at_offset(section_offset + 0x18, 0x00000000)        # RelocAddress
    pe_struct.set_dword_at_offset(section_offset + 0x1C, 0x00000000)        # LineNumbers
    pe_struct.set_word_at_offset(section_offset + 0x20, 0x0000)             # RelocationsNumber
    pe_struct.set_word_at_offset(section_offset + 0x22, 0x0000)             # LinenumbersNumber
    pe_struct.set_dword_at_offset(section_offset + 0x24, flags)             # Flags

    # Add (+1) new section
    pe_struct.FILE_HEADER.NumberOfSections +=1

    pe_struct.parse_sections(section_table_offset) # Fetch the PE file sections
    pe_struct = adjust_optional_header(pe_struct)

    return pe_struct

#####################################################
# Shellcode
#####################################################
